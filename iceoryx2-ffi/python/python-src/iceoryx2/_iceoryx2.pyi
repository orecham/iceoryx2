# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import typing
from enum import Enum

class ActiveRequest:
    r"""
    The `ActiveRequest` represents the object that contains the payload that the `Client` sends to the
    `Server`.
    """
    @property
    def __request_payload_type_details(self) -> typing.Optional[typing.Any]: ...
    @property
    def __request_header_type_details(self) -> typing.Optional[typing.Any]: ...
    @property
    def __response_payload_type_details(self) -> typing.Optional[typing.Any]: ...
    @property
    def __response_header_type_details(self) -> typing.Optional[typing.Any]: ...
    @property
    def __slice_len(self) -> builtins.int: ...
    @property
    def is_connected(self) -> builtins.bool:
        r"""
        Returns `True` until the `PendingResponse` goes out of scope on the `Client`s side
        indicating that the `Client` no longer receives the `ResponseMut`.
        """
    @property
    def payload_ptr(self) -> builtins.int:
        r"""
        Returns a pointer to the payload of the received `RequestMut`.
        """
    @property
    def user_header_ptr(self) -> builtins.int:
        r"""
        Returns a pointer to the user_header of the received `RequestMut`
        """
    @property
    def header(self) -> RequestHeader:
        r"""
        Returns the `RequestHeader` of the received `RequestMut`
        """
    @property
    def origin(self) -> UniqueClientId:
        r"""
        Returns the `UniqueClientId` of the `Client`
        """
    def delete(self) -> None:
        r"""
        Releases the `ActiveRequest` and terminates the connection.
        
        After this call the `ActiveRequest` is no longer usable!
        """
    def __loan_uninit(self) -> ResponseMutUninit:
        r"""
        Loans uninitialized memory for a `ResponseMut` where the user can write its payload to.
        """
    def __loan_slice_uninit(self, slice_len:builtins.int) -> ResponseMutUninit:
        r"""
        Loans/allocates a `ResponseMutUninit` from the underlying data segment of the
        `Server`. The user has to initialize the payload before it can be sent.
        
        On failure it emits `LoanError` describing the failure.
        """

class Alignment:
    r"""
    Contains the alignment memory can have.
    """
    @staticmethod
    def new(value:builtins.int) -> Alignment:
        r"""
        Creates a new `Alignment`. If the value is zero or not a power of 2
        it emits an `InvalidAlignmentValue`.
        """
    def value(self) -> builtins.int:
        r"""
        Returns the value of the `Alignment`
        """

class AliveNodeView:
    r"""
    Contains all details of a `Node` that is alive.
    """
    @property
    def id(self) -> NodeId:
        r"""
        Returns the `NodeId`.
        """
    @property
    def details(self) -> typing.Optional[NodeDetails]:
        r"""
        Returns optional `NodeDetails` that contains further information about the `Node`.
        Can only be acquired when the process has the access right to read it.
        """

class Attribute:
    r"""
    Represents a single service attribute (key-value) pair that can be defined when the service
    is being created.
    """
    @property
    def key(self) -> AttributeKey:
        r"""
        Acquires the service attribute key
        """
    @property
    def value(self) -> AttributeValue:
        r"""
        Acquires the service attribute value
        """
    @staticmethod
    def new(key:AttributeKey, value:AttributeValue) -> Attribute:
        r"""
        Creates an attribute instance
        """

class AttributeKey:
    r"""
    Relocatable (inter-process shared memory compatible) `SemanticString` implementation for
    `AttributeKey`.
    """
    @staticmethod
    def new(value:builtins.str) -> AttributeKey:
        r"""
        Creates a new `AttributeKey` when the provided `value` does not exceed
        `AttributeKey.max_len()`, otherwise it emits a `SemanticStringError`.
        """
    @staticmethod
    def max_len() -> builtins.int:
        r"""
        Returns the maximum length of a `AttributeKey`
        """
    def to_string(self) -> builtins.str:
        r"""
        Converts the `AttributeKey` into a `String`
        """

class AttributeSet:
    r"""
    Represents a single service attribute (key-value) pair that can be defined when the service
    is being created.
    """
    @property
    def number_of_attributes(self) -> builtins.int:
        r"""
        Returns the number of `Attribute`s stored inside the `AttributeSet`.
        """
    @property
    def values(self) -> builtins.list[Attribute]:
        r"""
        Returns all `Attribute`s stored in the `AttributeSet`
        """
    @staticmethod
    def capacity() -> builtins.int:
        r"""
        Returns the maximum number of `Attribute`s the `AttributeSet` can hold.
        """
    def key_values(self, key:AttributeKey) -> builtins.list[AttributeValue]:
        r"""
        Returns all `AttributeValue` that belong to a specified `AttributeKey`.
        """

class AttributeSpecifier:
    r"""
    Represents a single service attribute (key-value) pair that can be defined when the service
    is being created.
    """
    @property
    def attributes(self) -> AttributeSet:
        r"""
        Returns the underlying `AttributeSet`
        """
    @staticmethod
    def new() -> AttributeSpecifier:
        r"""
        Creates a new empty set of `Attribute`s
        """
    def define(self, key:AttributeKey, value:AttributeValue) -> AttributeSpecifier:
        r"""
        Defines a value for a specific key. A key is allowed to have multiple values.
        """

class AttributeValue:
    r"""
    Relocatable (inter-process shared memory compatible) `SemanticString` implementation for
    `AttributeValue`.
    """
    @staticmethod
    def new(value:builtins.str) -> AttributeValue:
        r"""
        Creates a new `AttributeValue` when the provided `value` does not exceed
        `AttributeValue.max_len()`, otherwise it emits a `SemanticStringError`.
        """
    @staticmethod
    def max_len() -> builtins.int:
        r"""
        Returns the maximum length of a `AttributeValue`
        """
    def to_string(self) -> builtins.str:
        r"""
        Converts the `AttributeValue` into a `String`
        """

class AttributeVerifier:
    r"""
    Represents a single service attribute (key-value) pair that can be defined when the service
    is being created.
    """
    @property
    def required_attributes(self) -> AttributeSet:
        r"""
        Returns the underlying required `AttributeSet`
        """
    @property
    def required_keys(self) -> builtins.list[AttributeKey]:
        r"""
        Returns the underlying required keys
        """
    @staticmethod
    def new() -> AttributeVerifier:
        r"""
        Creates a new empty set of `Attribute`s
        """
    def require(self, key:AttributeKey, value:AttributeValue) -> AttributeVerifier:
        r"""
        Requires a value for a specific key. A key is allowed to have multiple values.
        """
    def require_key(self, key:AttributeKey) -> AttributeVerifier:
        r"""
        Requires that a specific key is defined.
        """
    def verify_requirements(self, rhs:AttributeSet) -> typing.Optional[AttributeKey]:
        r"""
        Verifies if the `AttributeSet` contains all required keys and key-value pairs. If it does
        not satisfy the requirements it returns the first
        """

class CleanupState:
    r"""
    Returned by `Node.cleanup_dead_nodes()`. Contains the cleanup report of the call
    and contains the number of dead nodes that were successfully cleaned up and how many
    could not be cleaned up.
    This does not have to be an error, for instance when the current process does not
    have the permission to access the corresponding resources.
    """
    @property
    def cleanups(self) -> builtins.int:
        r"""
        The number of successful dead node cleanups
        """
    @property
    def failed_cleanups(self) -> builtins.int:
        r"""
        The number of failed dead node cleanups
        """

class Client:
    r"""
    Represents the receiving endpoint of an event based communication.
    """
    @property
    def __request_payload_type_details(self) -> typing.Optional[typing.Any]: ...
    @property
    def __request_header_type_details(self) -> typing.Optional[typing.Any]: ...
    @property
    def __response_payload_type_details(self) -> typing.Optional[typing.Any]: ...
    @property
    def __response_header_type_details(self) -> typing.Optional[typing.Any]: ...
    @property
    def id(self) -> UniqueClientId:
        r"""
        Returns the `UniqueClientId` of the `Client`
        """
    @property
    def unable_to_deliver_strategy(self) -> UnableToDeliverStrategy:
        r"""
        Returns the strategy the `Client` follows when a `RequestMut` cannot be delivered
        if the `Server`s buffer is full.
        """
    def delete(self) -> None:
        r"""
        Releases the `Client`.
        
        After this call the `Client` is no longer usable!
        """
    def __loan_uninit(self) -> RequestMutUninit:
        r"""
        Acquires an `RequestMutUninit` to store payload. This API shall be used
        by default to avoid unnecessary copies.
        """
    def __loan_slice_uninit(self, slice_len:builtins.int) -> RequestMutUninit:
        r"""
        Loans/allocates a `RequestMutUninit` from the underlying data segment of the `Client`.
        The user has to initialize the payload before it can be sent.
        
        On failure it emits a `LoanError` describing the failure.
        """
    def initial_max_slice_len(self) -> builtins.int:
        r"""
        Returns the maximum initial slice length configured for this `Client`.
        """

class Config:
    r"""
    Represents the configuration that iceoryx2 will utilize. It is divided into two sections:
    the [Global] settings, which must align with the iceoryx2 instance the application intends to
    join, and the [Defaults] for communication within that iceoryx2 instance. The user has the
    flexibility to override both sections.
    """
    @property
    def global_cfg(self) -> Global:
        r"""
        Returns the `Global` part of the config
        """
    @property
    def defaults(self) -> Defaults:
        r"""
        Returns the `Defaults` part of the config
        """
    def __eq__(self, other:Config) -> builtins.bool: ...
    def __str__(self) -> builtins.str: ...

class DeadNodeView:
    r"""
    Contains all details of a `Node` that is dead.
    """
    @property
    def id(self) -> NodeId:
        r"""
        Returns the `NodeId`.
        """
    @property
    def details(self) -> typing.Optional[NodeDetails]:
        r"""
        Returns optional `NodeDetails` that contains further information about the `Node`.
        Can only be acquired when the process has the access right to read it.
        """
    def remove_stale_resources(self) -> builtins.bool:
        r"""
        Removes all stale resources of the dead `Node`. On error it emits a `NodeCleanupFailure`.
        It returns true if the stale resources could be removed, otherwise false.
        """

class Defaults:
    r"""
    Default settings. These values are used when the user in the code does not specify anything
    else.
    """
    @property
    def publish_subscribe(self) -> PublishSubscribe:
        r"""
        Returns the publish_subscribe part of the default settings
        """
    @property
    def event(self) -> Event:
        r"""
        Returns the event part of the default settings
        """
    @property
    def request_response(self) -> RequestResponse:
        r"""
        Returns the request_response part of the default settings
        """
    def __str__(self) -> builtins.str: ...

class Duration:
    r"""
    Represents a time duration.
    """
    @staticmethod
    def from_micros(micros:builtins.int) -> Duration:
        r"""
        Creates a new `Duration` from a given number of micro seconds
        """
    @staticmethod
    def from_millis(millis:builtins.int) -> Duration:
        r"""
        Creates a new `Duration` from a given number of milli seconds
        """
    @staticmethod
    def from_nanos(nanos:builtins.int) -> Duration:
        r"""
        Creates a new `Duration` from a given number of nano seconds
        """
    @staticmethod
    def from_secs(secs:builtins.int) -> Duration:
        r"""
        Creates a new `Duration` from a given number of seconds
        """
    @staticmethod
    def from_secs_f64(secs:builtins.float) -> Duration:
        r"""
        Creates a new `Duration` from a given number of seconds
        """
    def as_secs(self) -> builtins.int:
        r"""
        Returns the number of seconds stored in the `Duration`
        """
    def as_secs_f64(self) -> builtins.float:
        r"""
        Returns the number of seconds stored in the `Duration`
        """
    def as_millis(self) -> builtins.int:
        r"""
        Returns the number of milli seconds stored in the `Duration`
        """
    def as_micros(self) -> builtins.int:
        r"""
        Returns the number of micro seconds stored in the `Duration`
        """
    def as_nanos(self) -> builtins.int:
        r"""
        Returns the number of nano seconds stored in the `Duration`
        """
    def subsec_micros(self) -> builtins.int:
        r"""
        Returns the fractional micro seconds part stored in the `Duration`
        """
    def subsec_millis(self) -> builtins.int:
        r"""
        Returns the fractional milli seconds part stored in the `Duration`
        """
    def subsec_nanos(self) -> builtins.int:
        r"""
        Returns the fractional nano seconds part stored in the `Duration`
        """

class Event:
    r"""
    Default settings for the event messaging pattern. These settings are used unless
    the user specifies custom QoS or port settings.
    """
    @property
    def max_listeners(self) -> builtins.int:
        r"""
        The maximum amount of supported `Listener`
        """
    @property
    def max_notifiers(self) -> builtins.int:
        r"""
        The maximum amount of supported `Notifier`
        """
    @property
    def max_nodes(self) -> builtins.int:
        r"""
        The maximum amount of supported `Node`s. Defines indirectly how many
        processes can open the service at the same time.
        """
    @property
    def event_id_max_value(self) -> builtins.int:
        r"""
        The largest event id supported by the event service
        """
    @property
    def deadline(self) -> Duration:
        r"""
        Defines the maximum allowed time between two consecutive notifications. If a notifiation
        is not sent after the defined time, every `Listener`
        that is attached to a `WaitSet` will be notified.
        """
    @property
    def notifier_created_event(self) -> builtins.int:
        r"""
        Defines the event id value that is emitted after a new notifier was created. If it is
        not set then `usize::MAX` is returned
        """
    @property
    def has_notifier_created_event(self) -> builtins.bool:
        r"""
        Returns true if the notifier created event was set, otherwise false.
        """
    @property
    def notifier_dropped_event(self) -> builtins.int:
        r"""
        Defines the event id value that is emitted before a new notifier is dropped.
        """
    @property
    def has_notifier_dropped_event(self) -> builtins.bool:
        r"""
        Returns true if the notifier dropped event was set, otherwise false.
        """
    @property
    def notifier_dead_event(self) -> builtins.int:
        r"""
        Defines the event id value that is emitted if a notifier was identified as dead.
        """
    @property
    def has_notifier_dead_event(self) -> builtins.bool:
        r"""
        Returns true if the notifier dead event was set, otherwise false.
        """
    @max_listeners.setter
    def max_listeners(self, value: builtins.int) -> None:
        r"""
        Set the maximum amount of supported `Listener`
        """
    @max_notifiers.setter
    def max_notifiers(self, value: builtins.int) -> None:
        r"""
        Set the maximum amount of supported `Notifier`
        """
    @max_nodes.setter
    def max_nodes(self, value: builtins.int) -> None:
        r"""
        Set the maximum amount of supported `Node`s.
        """
    @event_id_max_value.setter
    def event_id_max_value(self, value: builtins.int) -> None:
        r"""
        Set the largest event id supported by the event service
        """
    @deadline.setter
    def deadline(self, value: Duration) -> None:
        r"""
        Sets the deadline of the event service.
        """
    @notifier_created_event.setter
    def notifier_created_event(self, value: builtins.int) -> None:
        r"""
        Sets the event id value that is emitted after a new notifier was created.
        """
    @notifier_dropped_event.setter
    def notifier_dropped_event(self, value: builtins.int) -> None:
        r"""
        Sets the event id value that is emitted before a new notifier is dropped.
        """
    @notifier_dead_event.setter
    def notifier_dead_event(self, value: builtins.int) -> None:
        r"""
        Sets the event id value that is emitted if a notifier was identified as dead.
        """
    def __str__(self) -> builtins.str: ...
    def disable_notifier_created_event(self) -> None:
        r"""
        Do not emit an event whenever a notifier was created.
        """
    def disable_notifier_dropped_event(self) -> None:
        r"""
        Do not emit an event whenever a notifier was dropped.
        """
    def disable_notifier_dead_event(self) -> None:
        r"""
        Do not emit an event whenever a notifier was identified as dead.
        """

class EventId:
    r"""
    User defined identifier that can be provided in `Notifier.notify()` to signal a specific
    kind of event.
    """
    @property
    def as_value(self) -> builtins.int:
        r"""
        Returns the integer value of the `EventId`
        """
    @staticmethod
    def new(value:builtins.int) -> EventId:
        r"""
        Creates a new `EventId` from a given integer value
        """

class FileDescriptor:
    r"""
    Represents a FileDescriptor in a POSIX system. Contains always a value greater or equal zero,
    a valid file descriptor. It takes the ownership of the provided file descriptor and calls
    `posix::close` on destruction.
    """
    @property
    def native_handle(self) -> builtins.int:
        r"""
        Returns the underlying value of the FileDescriptor
        
        # Safety
        
         * the user shall not store the value in a variable otherwise lifetime issues may be
           encountered
         * do not manually close the file descriptor with a sys call
        """
    @staticmethod
    def non_owning_new(value:builtins.int) -> typing.Optional[FileDescriptor]:
        r"""
        Creates a FileDescriptor which does not hold the ownership of the file descriptor and will
        not call `posix::close` on destruction.
        """
    @staticmethod
    def new(value:builtins.int) -> typing.Optional[FileDescriptor]:
        r"""
        Creates a new FileDescriptor. If the value is smaller than zero it returns [`None`].
        """

class FileName:
    r"""
    Relocatable (inter-process shared memory compatible) `SemanticString` implementation for
    `FileName`. All modification operations ensure that never an
    invalid file or path name can be generated. All strings have a fixed size so that the maximum
    path or file name length the system supports can be stored.
    """
    @staticmethod
    def new(name:builtins.str) -> FileName:
        r"""
        Creates a new `FileName` when the provided `name` contains a valid path to a file,
        otherwise it emits a `SemanticStringError`.
        """
    @staticmethod
    def max_len() -> builtins.int:
        r"""
        Returns the maximum length of a `FileName`
        """
    def to_string(self) -> builtins.str:
        r"""
        Converts the `FileName` into a `String`
        """

class FilePath:
    r"""
    Relocatable (inter-process shared memory compatible) `SemanticString` implementation for
    `FilePath`. All modification operations ensure that never an
    invalid file or path name can be generated. All strings have a fixed size so that the maximum
    path or file name length the system supports can be stored.
    """
    @staticmethod
    def new(name:builtins.str) -> FilePath:
        r"""
        Creates a new `FilePath` when the provided `name` contains a valid path to a file,
        otherwise it emits a `SemanticStringError`.
        """
    @staticmethod
    def max_len() -> builtins.int:
        r"""
        Returns the maximum length of a `FilePath`
        """
    def to_string(self) -> builtins.str:
        r"""
        Converts the `FilePath` into a `String`
        """

class Global:
    r"""
    The global settings
    """
    @property
    def service(self) -> Service:
        r"""
        Returns the service part of the global configuration
        """
    @property
    def node(self) -> Node:
        r"""
        Returns the node part of the global configuration
        """
    @property
    def service_dir(self) -> Path:
        r"""
        Returns the directory under which service files are stored.
        """
    @property
    def node_dir(self) -> Path:
        r"""
        Returns the directory under which node files are stored.
        """
    @property
    def root_path(self) -> Path:
        r"""
        The path under which all other directories or files will be created
        """
    @property
    def prefix(self) -> FileName:
        r"""
        Prefix used for all files created during runtime
        """
    @root_path.setter
    def root_path(self, value: Path) -> None:
        r"""
        Defines the path under which all other directories or files will be created
        """
    @prefix.setter
    def prefix(self, value: FileName) -> None:
        r"""
        Set the prefix used for all files created during runtime
        """
    def __str__(self) -> builtins.str: ...

class HeaderPublishSubscribe:
    r"""
    Sample header used by `MessagingPattern::PublishSubscribe`
    """
    @property
    def node_id(self) -> NodeId:
        r"""
        Returns the `NodeId` of the source node that published the `Sample`.
        """
    @property
    def publisher_id(self) -> UniquePublisherId:
        r"""
        Returns the `UniquePublisherId` of the source `Publisher`.
        """
    @property
    def number_of_elements(self) -> builtins.int:
        r"""
        Returns how many elements are stored inside the `Sample`'s payload.
        """

class Listener:
    r"""
    Represents the receiving endpoint of an event based communication.
    """
    @property
    def deadline(self) -> typing.Optional[Duration]:
        r"""
        Returns the deadline of the corresponding `Service`.
        """
    @property
    def id(self) -> UniqueListenerId:
        r"""
        Returns the `UniqueListenerId` of the `Listener`
        """
    def try_wait_one(self) -> typing.Optional[EventId]:
        r"""
        Non-blocking wait for a new `EventId`. If no `EventId` was notified it returns `None`.
        On error it emits `ListenerWaitError`.
        """
    def timed_wait_one(self, timeout:Duration) -> typing.Optional[EventId]:
        r"""
        Blocking wait for a new `EventId` until either an `EventId` was received or the timeout
        has passed. If no `EventId` was notified it returns `None`.
        On error it emits `ListenerWaitError`.
        """
    def blocking_wait_one(self) -> typing.Optional[EventId]:
        r"""
        Blocking wait for a new `EventId`.
        Sporadic wakeups can occur and if no `EventId` was notified it returns `None`.
        On error it emits `ListenerWaitError`.
        """
    def try_wait_all(self) -> builtins.list[EventId]:
        r"""
        Non-blocking wait for new `EventId`s. Collects all `EventId`s that were received and
        calls the provided callback is with the `EventId` as input argument.
        On error it emits `ListenerWaitError`.
        """
    def timed_wait_all(self, timeout:Duration) -> builtins.list[EventId]:
        r"""
        Blocking wait for new `EventId`s until the provided timeout has passed. Unblocks as soon
        as an `EventId` was received and then collects all `EventId`s that were received and
        calls the provided callback is with the `EventId` as input argument.
        On error it emits `ListenerWaitError`.
        """
    def blocking_wait_all(self) -> builtins.list[EventId]:
        r"""
        Blocking wait for new `EventId`s. Unblocks as soon
        as an `EventId` was received and then collects all `EventId`s that were received and
        calls the provided callback is with the `EventId` as input argument.
        On error it emits `ListenerWaitError`.
        """
    def delete(self) -> None:
        r"""
        Releases the `Listener`.
        
        After this call the `Listener` is no longer usable!
        """

class MessageTypeDetails:
    r"""
    Contains all type information to the header and payload type.
    """
    @property
    def header(self) -> TypeDetail:
        r"""
        The `TypeDetail` of the header of a message, the first iceoryx2 internal part.
        """
    @property
    def user_header(self) -> TypeDetail:
        r"""
        The `TypeDetail` of the user_header or the custom header, is located directly after the
        header.
        """
    @property
    def payload(self) -> TypeDetail:
        r"""
        The `TypeDetail` of the payload of the message, the last part.
        """

class Node:
    r"""
    All configurable settings of a `Node`.
    """
    @property
    def directory(self) -> Path:
        r"""
        The directory in which all node files are stored
        """
    @property
    def monitor_suffix(self) -> FileName:
        r"""
        The suffix of the monitor token
        """
    @property
    def static_config_suffix(self) -> FileName:
        r"""
        The suffix of the files where the node configuration is stored.
        """
    @property
    def service_tag_suffix(self) -> FileName:
        r"""
        The suffix of the service tags.
        """
    @property
    def cleanup_dead_nodes_on_creation(self) -> builtins.bool:
        r"""
        When true, the `NodeBuilder` checks for dead nodes and
        cleans up all their stale resources whenever a new [`Node`](Node) is
        created.
        """
    @property
    def cleanup_dead_nodes_on_destruction(self) -> builtins.bool:
        r"""
        When true, the `NodeBuilder` checks for dead nodes and
        cleans up all their stale resources whenever an existing `Node` is
        going out of scope.
        """
    @directory.setter
    def directory(self, value: Path) -> None:
        r"""
        Set the directory in which all node files are stored
        """
    @monitor_suffix.setter
    def monitor_suffix(self, value: FileName) -> None:
        r"""
        Set the suffix of the monitor token
        """
    @static_config_suffix.setter
    def static_config_suffix(self, value: FileName) -> None:
        r"""
        Set the suffix of the files where the node configuration is stored.
        """
    @service_tag_suffix.setter
    def service_tag_suffix(self, value: FileName) -> None:
        r"""
        Set the suffix of the service tags.
        """
    @cleanup_dead_nodes_on_creation.setter
    def cleanup_dead_nodes_on_creation(self, value: builtins.bool) -> None:
        r"""
        Enable/disable the cleanup dead nodes on creation
        """
    @cleanup_dead_nodes_on_destruction.setter
    def cleanup_dead_nodes_on_destruction(self, value: builtins.bool) -> None:
        r"""
        Enable/disable the cleanup dead nodes on destruction
        """
    def __str__(self) -> builtins.str: ...

class Node:
    r"""
    The central entry point of iceoryx2. Represents a node of the iceoryx2
    system. One process can have arbitrary many nodes but usually it should be
    only one node per process.
    Can be created via the `NodeBuilder`.
    """
    @property
    def name(self) -> NodeName:
        r"""
        Returns the name of the node inside a `NodeName`.
        """
    @property
    def config(self) -> Config:
        r"""
        Returns the `Config` that the `Node` will use to create any iceoryx2 entity.
        """
    @property
    def id(self) -> NodeId:
        r"""
        Returns the unique id of the `Node`.
        """
    @property
    def signal_handling_mode(self) -> SignalHandlingMode:
        r"""
        Returns the `SignalHandlingMode` with which the `Node` was created.
        """
    def __str__(self) -> builtins.str: ...
    @staticmethod
    def list(service_type:ServiceType, config:Config) -> builtins.list[NodeState]:
        r"""
        Returns a list of `NodeState`s of all `Node`s under a provided config.
        On failure it emits a `NodeListFailure`.
        """
    def service_builder(self, name:ServiceName) -> ServiceBuilder:
        r"""
        Instantiates a `ServiceBuilder` for a service with the provided name.
        """
    def wait(self, cycle_time:Duration) -> None:
        r"""
        Waits for a given `cycle_time`.
        On failure it emits a `NodeWaitFailure`.
        """
    @staticmethod
    def cleanup_dead_nodes(service_type:ServiceType, config:Config) -> CleanupState:
        r"""
        Removes the stale system resources of all dead `Node`s. The dead `Node`s are also
        removed from all registered `Service`s.
        
        If a `Node` cannot be cleaned up since the process has insufficient permissions then
        the `Node` is skipped.
        """

class NodeBuilder:
    r"""
    Creates a new `Node`.
    """
    @staticmethod
    def new() -> NodeBuilder:
        r"""
        Instantiates a new `NodeBuilder`
        """
    def name(self, value:NodeName) -> NodeBuilder:
        r"""
        The `NodeName` that shall be assigned to the `Node`. It does not
        have to be unique. If no `NodeName` is defined then the `Node`
        does not have a name.
        """
    def signal_handling_mode(self, value:SignalHandlingMode) -> NodeBuilder:
        r"""
        Defines the `SignalHandlingMode` for the `Node`. It affects the `Node.wait()` call
        that returns any received signal via its `NodeWaitFailure`
        """
    def config(self, config:Config) -> NodeBuilder:
        r"""
        The `Config` that shall be used for the `Node`. If no `Config`
        is specified the `config.global_config()` is used.
        """
    def create(self, service_type:ServiceType) -> Node:
        r"""
        Creates a new `Node` for a specified `ServiceType`.
        Emits `NodeCreationFailure` on failure.
        """

class NodeDetails:
    r"""
    Contains details of a `Node`.
    """
    @property
    def executable(self) -> FileName:
        r"""
        Returns the executable `FileName` of the `Node`s owner process.
        """
    @property
    def name(self) -> NodeName:
        r"""
        Returns a reference of the `NodeName`.
        """
    @property
    def config(self) -> Config:
        r"""
        Returns a reference to the `Config` the `Node` uses.
        """

class NodeId:
    r"""
    The system-wide unique id of a `Node`
    """
    @property
    def value(self) -> builtins.int:
        r"""
        Returns the underlying integer value of the `NodeId`.
        """
    @property
    def pid(self) -> builtins.int:
        r"""
        Returns the process id of the process that owns the `Node`.
        """
    def __eq__(self, other:NodeId) -> builtins.bool: ...

class NodeName:
    r"""
    Represent the name for a `Node`.
    """
    @staticmethod
    def new(name:builtins.str) -> NodeName:
        r"""
        Creates a new `NodeName`.
        If the provided name does not contain a valid `NodeName` it will emit
        `SemanticStringError`, otherwise the `NodeName`.
        """
    @staticmethod
    def max_len() -> builtins.int:
        r"""
        Returns the maximum length of a `NodeName`
        """
    def as_str(self) -> builtins.str:
        r"""
        Converts the `NodeName` into a `String`
        """

class NodeState:
    r"""
    Describes the state of a `Node`.
    """
    class Alive(NodeState):
        r"""
        The `Node`s process is still alive.
        """
        __match_args__ = ("_0",)
        @property
        def _0(self) -> AliveNodeView: ...
        def __new__(cls, _0:AliveNodeView) -> NodeState.Alive: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class Dead(NodeState):
        r"""
        The `Node`s process died without cleaning up the `Node`s resources. Another process has
        now the responsibility to cleanup all the stale resources.
        """
        __match_args__ = ("_0",)
        @property
        def _0(self) -> DeadNodeView: ...
        def __new__(cls, _0:DeadNodeView) -> NodeState.Dead: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class Inaccessible(NodeState):
        r"""
        The process does not have sufficient permissions to identify the `Node` as dead or alive.
        """
        __match_args__ = ("_0",)
        @property
        def _0(self) -> NodeId: ...
        def __new__(cls, _0:NodeId) -> NodeState.Inaccessible: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    class Undefined(NodeState):
        r"""
        The `Node` is in an undefined state, meaning that certain elements are missing,
        misconfigured or inconsistent. This can only happen due to an implementation failure or
        when the corresponding `Node` resources were altered.
        """
        __match_args__ = ("_0",)
        @property
        def _0(self) -> NodeId: ...
        def __new__(cls, _0:NodeId) -> NodeState.Undefined: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key:builtins.int) -> typing.Any: ...
    
    ...

class Notifier:
    r"""
    Represents the sending endpoint of an event based communication.
    """
    @property
    def id(self) -> UniqueNotifierId:
        r"""
        Returns the `UniqueNotifierId` of the `Notifier`
        """
    @property
    def deadline(self) -> typing.Optional[Duration]:
        r"""
        Returns the deadline of the corresponding `Service`.
        """
    def notify(self) -> builtins.int:
        r"""
        Notifies all `Listener` connected to the service with the default
        event id provided on creation.
        Returns on success the number of `Listener`s that were notified otherwise it emits
        `NotifierNotifyError`.
        """
    def notify_with_custom_event_id(self, event_id:EventId) -> builtins.int:
        r"""
        Notifies all `Listener` connected to the service with a custom `EventId`.
        Returns on success the number of `Listener`s that were notified otherwise it returns
        `NotifierNotifyError`.
        """
    def delete(self) -> None:
        r"""
        Releases the `Notifier`.
        
        After this call the `Notifier` is no longer usable!
        """

class Path:
    r"""
    Relocatable (inter-process shared memory compatible) SemanticString implementation for
    `Path`. All modification operations ensure that never an
    invalid file or path name can be generated. All strings have a fixed size so that the maximum
    path or file name length the system supports can be stored.
    """
    @staticmethod
    def new(name:builtins.str) -> Path:
        r"""
        Creates a new `Path` when the provided `name` contains a valid path, otherwise it emits a
        `SemanticStringError`.
        """
    @staticmethod
    def max_len() -> builtins.int:
        r"""
        Returns the maximum length of a `Path`
        """
    def to_string(self) -> builtins.str:
        r"""
        Converts the `Path` into a `String`
        """

class PendingResponse:
    r"""
    Represents an active connection to all `Server` that received the `RequestMut`. The
    `Client` can use it to receive the corresponding `Response`s.
    
    As soon as it goes out of scope, the connections are closed and the `Server`s are informed.
    """
    @property
    def __request_payload_type_details(self) -> typing.Optional[typing.Any]: ...
    @property
    def __request_header_type_details(self) -> typing.Optional[typing.Any]: ...
    @property
    def __response_payload_type_details(self) -> typing.Optional[typing.Any]: ...
    @property
    def __response_header_type_details(self) -> typing.Optional[typing.Any]: ...
    def is_connected(self) -> builtins.bool:
        r"""
        Returns `True` until the `ActiveRequest` goes out of scope on the `Server`s side
        indicating that the `Server` will no longer send `Response`s.
        It also returns `False` when there are no `Server`.
        """
    def header(self) -> RequestHeader:
        r"""
        Returns a reference to the iceoryx2 internal `RequestHeader` of the corresponding
        `RequestMut`
        """
    def user_header_ptr(self) -> builtins.int:
        r"""
        Returns a pointer to the user defined request header of the corresponding
        `RequestMut`
        """
    def payload_ptr(self) -> builtins.int:
        r"""
        Returns a pointer to the request payload of the corresponding
        `RequestMut`
        """
    def number_of_server_connections(self) -> builtins.int:
        r"""
        Returns how many `Server`s received the corresponding `RequestMut` initially.
        """
    def has_response(self) -> builtins.bool:
        r"""
        Returns `True` when a `Server` has sent a `Response` otherwise `False`.
        """
    def delete(self) -> None:
        r"""
        Releases the `PendingResponse` and signals the `Server` that the `Client` is no longer
        interested in receiving any more `Response`s and terminates the connection.
        
        After this call the `PendingResponse` is no longer usable!
        """
    def receive(self) -> typing.Optional[Response]:
        r"""
        Receives a `Response` from one of the `Server`s that received the `RequestMut`.
        """

class PortFactoryClient:
    r"""
    Factory to create a new `Client` port/endpoint for `MessagingPattern::RequestResponse`
    based communication.
    """
    @property
    def __request_payload_type_details(self) -> typing.Optional[typing.Any]: ...
    @property
    def __request_header_type_details(self) -> typing.Optional[typing.Any]: ...
    @property
    def __response_payload_type_details(self) -> typing.Optional[typing.Any]: ...
    @property
    def __response_header_type_details(self) -> typing.Optional[typing.Any]: ...
    def unable_to_deliver_strategy(self, value:UnableToDeliverStrategy) -> PortFactoryClient:
        r"""
        Sets the `UnableToDeliverStrategy` which defines how the `Client` shall behave
        when a `Server` cannot receive a `RequestMut` since its internal buffer is full.
        """
    def __initial_max_slice_len(self, value:builtins.int) -> PortFactoryClient:
        r"""
        Sets the maximum slice length that a user can allocate with
        `Client::loan_slice()` or `Client::loan_slice_uninit()`.
        """
    def __allocation_strategy(self, value:AllocationStrategy) -> PortFactoryClient:
        r"""
        Defines the allocation strategy that is used when the provided
        `PortFactoryClient::initial_max_slice_len()` is exhausted. This happens when the user
        acquires more than max slice len in `Client::loan_slice()` or `Client::loan_slice_uninit()`.
        """
    def create(self) -> Client:
        r"""
        Creates a new `Client` or emits a `ClientCreateError` on failure.
        """

class PortFactoryEvent:
    r"""
    The factory for `MessagingPattern::Event`. It can acquire dynamic and static service
    informations and create `Notifier` or `Listener` ports.
    """
    @property
    def name(self) -> ServiceName:
        r"""
        Returns the `ServiceName` of the service
        """
    @property
    def service_id(self) -> ServiceId:
        r"""
        Returns the `ServiceId` of the `Service`
        """
    @property
    def attributes(self) -> AttributeSet:
        r"""
        Returns the `AttributeSet` defined in the `Service`
        """
    @property
    def static_config(self) -> StaticConfigEvent:
        r"""
        Returns the StaticConfig of the `Service`.
        Contains all settings that never change during the lifetime of the service.
        """
    @property
    def nodes(self) -> builtins.list[NodeState]:
        r"""
        Returns a list of all `NodeState` of all the `Node`s which have opened the `Service`.
        """
    def listener_builder(self) -> PortFactoryListener:
        r"""
        Returns a `PortFactoryListener` to create a new `Listener` port
        """
    def notifier_builder(self) -> PortFactoryNotifier:
        r"""
        Returns a `PortFactoryNotifier` to create a new `Notifier` port
        """

class PortFactoryListener:
    r"""
    Factory to create a new `Listener` port/endpoint for `MessagingPattern::Event` based
    communication.
    """
    def create(self) -> Listener:
        r"""
        Creates the `Listener` port or emits a `ListenerCreateError` on failure.
        """

class PortFactoryNotifier:
    r"""
    Factory to create a new `Notifier` port/endpoint for `MessagingPattern::Event` based
    communication.
    """
    def create(self) -> Notifier:
        r"""
        Creates a new `Notifier` port or emits a `NotifierCreateError` on failure.
        """
    def default_event_id(self, value:EventId) -> PortFactoryNotifier:
        r"""
        Sets a default `EventId` for the `Notifier` that is used in `Notifier.notify()`
        """

class PortFactoryPublishSubscribe:
    r"""
    The factory for `MessagingPattern::PublishSubscribe`. It can acquire dynamic and static service
    informations and create `Publisher` or `Subscriber` ports.
    """
    @property
    def name(self) -> ServiceName:
        r"""
        Returns the `ServiceName` of the service
        """
    @property
    def service_id(self) -> ServiceId:
        r"""
        Returns the `ServiceId` of the `Service`
        """
    @property
    def attributes(self) -> AttributeSet:
        r"""
        Returns the `AttributeSet` defined in the `Service`
        """
    @property
    def static_config(self) -> StaticConfigPublishSubscribe:
        r"""
        Returns the StaticConfig of the `Service`.
        Contains all settings that never change during the lifetime of the service.
        """
    @property
    def nodes(self) -> builtins.list[NodeState]:
        r"""
        Returns a list of all `NodeState` of all the `Node`s which have opened the `Service`.
        """
    def publisher_builder(self) -> PortFactoryPublisher:
        r"""
        Returns a `PortFactoryPublisher` to create a new `Publisher` port
        """
    def subscriber_builder(self) -> PortFactorySubscriber:
        r"""
        Returns a `PortFactorySubscriber` to create a new `Subscriber` port
        """

class PortFactoryPublisher:
    r"""
    Factory to create a new `Publisher` port/endpoint for `MessagingPattern::PublishSubscribe`
    based communication.
    """
    @property
    def __payload_type_details(self) -> typing.Optional[typing.Any]: ...
    def max_loaned_samples(self, value:builtins.int) -> PortFactoryPublisher:
        r"""
        Defines how many `SampleMut` the `Publisher` can loan with `Publisher::loan()` or
        `Publisher::loan_uninit()` in parallel.
        """
    def unable_to_deliver_strategy(self, value:UnableToDeliverStrategy) -> PortFactoryPublisher:
        r"""
        Sets the `UnableToDeliverStrategy`.
        """
    def __initial_max_slice_len(self, value:builtins.int) -> PortFactoryPublisher:
        r"""
        Sets the maximum slice length that a user can allocate with
        `ActiveRequest::loan_slice()` or `ActiveRequest::loan_slice_uninit()`.
        """
    def __allocation_strategy(self, value:AllocationStrategy) -> PortFactoryPublisher:
        r"""
        Defines the allocation strategy that is used when the provided
        `PortFactoryServer::initial_max_slice_len()` is exhausted. This happens when the user
        acquires more than max slice len in `ActiveRequest::loan_slice()` or
        `ActiveRequest::loan_slice_uninit()`.
        """
    def create(self) -> Publisher:
        r"""
        Creates a new `Publisher` or emits a `PublisherCreateError` on failure.
        """

class PortFactoryRequestResponse:
    r"""
    The factory for `MessagingPattern::RequestResponse`. It can acquire dynamic and static service
    informations and create `Client` or `Server` ports.
    """
    @property
    def name(self) -> ServiceName:
        r"""
        Returns the `ServiceName` of the service
        """
    @property
    def service_id(self) -> ServiceId:
        r"""
        Returns the `ServiceId` of the `Service`
        """
    @property
    def attributes(self) -> AttributeSet:
        r"""
        Returns the `AttributeSet` defined in the `Service`
        """
    @property
    def static_config(self) -> StaticConfigRequestResponse:
        r"""
        Returns the StaticConfig of the `Service`.
        Contains all settings that never change during the lifetime of the service.
        """
    @property
    def nodes(self) -> builtins.list[NodeState]:
        r"""
        Returns a list of all `NodeState` of all the `Node`s which have opened the `Service`.
        """
    def server_builder(self) -> PortFactoryServer:
        r"""
        Returns a `PortFactoryServer` to create a new `Server` port
        """
    def client_builder(self) -> PortFactoryClient:
        r"""
        Returns a `PortFactoryClient` to create a new `Client` port
        """

class PortFactoryServer:
    r"""
    Factory to create a new `Server` port/endpoint for `MessagingPattern::RequestResponse` based
    communication.
    """
    @property
    def __request_payload_type_details(self) -> typing.Optional[typing.Any]: ...
    @property
    def __request_header_type_details(self) -> typing.Optional[typing.Any]: ...
    @property
    def __response_payload_type_details(self) -> typing.Optional[typing.Any]: ...
    @property
    def __response_header_type_details(self) -> typing.Optional[typing.Any]: ...
    def unable_to_deliver_strategy(self, value:UnableToDeliverStrategy) -> PortFactoryServer:
        r"""
        Sets the `UnableToDeliverStrategy` which defines how the `Server` shall behave
        when a `Client` cannot receive a `Response` since its internal buffer is full.
        """
    def max_loaned_responses_per_request(self, value:builtins.int) -> PortFactoryServer:
        r"""
        Defines the maximum number of `ResponseMut` that
        the `Server` can loan in parallel per
        `ActiveRequest`.
        """
    def __initial_max_slice_len(self, value:builtins.int) -> PortFactoryServer:
        r"""
        Sets the maximum slice length that a user can allocate with
        `ActiveRequest::loan_slice()` or `ActiveRequest::loan_slice_uninit()`.
        """
    def __allocation_strategy(self, value:AllocationStrategy) -> PortFactoryServer:
        r"""
        Defines the allocation strategy that is used when the provided
        `PortFactoryServer::initial_max_slice_len()` is exhausted. This happens when the user
        acquires more than max slice len in `ActiveRequest::loan_slice()` or
        `ActiveRequest::loan_slice_uninit()`.
        """
    def create(self) -> Server:
        r"""
        Creates a new `Server` or emits a `ServerCreateError` on failure.
        """

class PortFactorySubscriber:
    r"""
    Factory to create a new `Subscriber` port/endpoint for
    `MessagingPattern::PublishSubscribe` based communication.
    """
    def buffer_size(self, value:builtins.int) -> PortFactorySubscriber:
        r"""
        Defines the buffer size of the `Subscriber`. Smallest possible value is `1`.
        """
    def create(self) -> Subscriber:
        r"""
        Creates a new `Subscriber` or emits a `SubscriberCreateError` on failure.
        """

class PublishSubscribe:
    r"""
    Default settings for the publish-subscribe messaging pattern. These settings are used unless
    the user specifies custom QoS or port settings.
    """
    @property
    def max_subscribers(self) -> builtins.int:
        r"""
        The maximum amount of supported `Subscriber`s
        """
    @property
    def max_publishers(self) -> builtins.int:
        r"""
        The maximum amount of supported `Publisher`s
        """
    @property
    def max_nodes(self) -> builtins.int:
        r"""
        The maximum amount of supported `Node`s. Defines indirectly how many
        processes can open the service at the same time.
        """
    @property
    def subscriber_max_buffer_size(self) -> builtins.int:
        r"""
        The maximum buffer size a `Subscriber` can have
        """
    @property
    def subscriber_max_borrowed_samples(self) -> builtins.int:
        r"""
        The maximum amount of `Sample`s a `Subscriber` can hold at the same time.
        """
    @property
    def publisher_max_loaned_samples(self) -> builtins.int:
        r"""
        The maximum amount of `SampleMut`s a `Publisher` can loan at the same time.
        """
    @property
    def publisher_history_size(self) -> builtins.int:
        r"""
        The maximum history size a `Subscriber` can request from a `Publisher`.
        """
    @property
    def enable_safe_overflow(self) -> builtins.bool:
        r"""
        Defines how the `Subscriber` buffer behaves when it is
        full. When safe overflow is activated, the `Publisher` will
        replace the oldest `Sample` with the newest one.
        """
    @property
    def unable_to_deliver_strategy(self) -> UnableToDeliverStrategy:
        r"""
        If safe overflow is deactivated it defines the deliver strategy of the
        `Publisher` when the `Subscriber`s buffer is full.
        """
    @property
    def subscriber_expired_connection_buffer(self) -> builtins.int:
        r"""
        Defines the size of the internal `Subscriber`
        buffer that contains expired connections. An
        connection is expired when the `Publisher`
        disconnected from a service and the connection
        still contains unconsumed `Sample`s.
        """
    @max_subscribers.setter
    def max_subscribers(self, value: builtins.int) -> None:
        r"""
        Set the maximum amount of supported `Subscriber`s
        """
    @max_publishers.setter
    def max_publishers(self, value: builtins.int) -> None:
        r"""
        Set the maximum amount of supported `Publisher`s
        """
    @max_nodes.setter
    def max_nodes(self, value: builtins.int) -> None:
        r"""
        Set the maximum amount of supported `Node`s.
        """
    @subscriber_max_buffer_size.setter
    def subscriber_max_buffer_size(self, value: builtins.int) -> None:
        r"""
        Set the maximum buffer size a `Subscriber` can have
        """
    @subscriber_max_borrowed_samples.setter
    def subscriber_max_borrowed_samples(self, value: builtins.int) -> None:
        r"""
        Set the maximum amount of `Sample`s a `Subscriber` can hold at the same time.
        """
    @publisher_max_loaned_samples.setter
    def publisher_max_loaned_samples(self, value: builtins.int) -> None:
        r"""
        The maximum amount of `SampleMut`s a `Publisher` can loan at the same time.
        """
    @publisher_history_size.setter
    def publisher_history_size(self, value: builtins.int) -> None:
        r"""
        Set the maximum history size a `Subscriber` can request from a `Publisher`.
        """
    @enable_safe_overflow.setter
    def enable_safe_overflow(self, value: builtins.bool) -> None:
        r"""
        Enables/disables safe overflow
        """
    @unable_to_deliver_strategy.setter
    def unable_to_deliver_strategy(self, value: UnableToDeliverStrategy) -> None:
        r"""
        Define the unable to deliver strategy
        """
    @subscriber_expired_connection_buffer.setter
    def subscriber_expired_connection_buffer(self, value: builtins.int) -> None:
        r"""
        Set the expired connection buffer size
        """
    def __str__(self) -> builtins.str: ...

class Publisher:
    r"""
    Represents the receiving endpoint of an event based communication.
    """
    @property
    def __payload_type_details(self) -> typing.Optional[typing.Any]: ...
    @property
    def id(self) -> UniquePublisherId:
        r"""
        Returns the `UniquePublisherId` of the `Publisher`
        """
    @property
    def unable_to_deliver_strategy(self) -> UnableToDeliverStrategy:
        r"""
        Returns the strategy the `Publisher` follows when a `SampleMut` cannot be delivered
        since the `Subscriber`s buffer is full.
        """
    @property
    def initial_max_slice_len(self) -> builtins.int:
        r"""
        Returns the maximum initial slice length configured for this `Publisher`.
        """
    def __loan_uninit(self) -> SampleMutUninit:
        r"""
        Loans/allocates a `SampleMutUninit` from the underlying data segment of the `Publisher`.
        The user has to initialize the payload before it can be sent.
        
        On failure it returns `LoanError` describing the failure.
        """
    def __loan_slice_uninit(self, number_of_elements:builtins.int) -> SampleMutUninit:
        r"""
        Loans/allocates a `SampleMutUninit` from the underlying data segment of the `Publisher`.
        The user has to initialize the payload before it can be sent.
        Fails when it is called for data types which are not a slice.
        
        On failure it returns `LoanError` describing the failure.
        """
    def delete(self) -> None:
        r"""
        Releases the `Publisher`.
        
        After this call the `Publisher` is no longer usable!
        """

class RequestHeader:
    r"""
    Request header used by `MessagingPattern::RequestResponse`
    """
    @property
    def client_id(self) -> UniqueClientId:
        r"""
        Returns the `UniqueClientId` of the `Client` which sent the `RequestMut`
        """
    @property
    def number_of_elements(self) -> builtins.int:
        r"""
        Returns how many elements are stored inside the requests's payload.
        """

class RequestMut:
    r"""
    The `RequestMut` represents the object that contains the payload that the `Client` sends to the
    `Server`.
    """
    @property
    def __request_payload_type_details(self) -> typing.Optional[typing.Any]: ...
    @property
    def __request_header_type_details(self) -> typing.Optional[typing.Any]: ...
    @property
    def __response_payload_type_details(self) -> typing.Optional[typing.Any]: ...
    @property
    def __response_header_type_details(self) -> typing.Optional[typing.Any]: ...
    @property
    def __slice_len(self) -> builtins.int: ...
    @property
    def header(self) -> RequestHeader:
        r"""
        Returns the iceoryx2 internal `RequestHeader`
        """
    @property
    def user_header_ptr(self) -> builtins.int:
        r"""
        Returns a pointer to the user defined request header.
        """
    @property
    def payload_ptr(self) -> builtins.int:
        r"""
        Returns a pointer to the user defined request payload.
        """
    def delete(self) -> None:
        r"""
        Releases the `RequestMut`.
        
        After this call the `RequestMut` is no longer usable!
        """
    def send(self) -> PendingResponse:
        r"""
        Sends the `RequestMut` to all connected `Server`s of the `Service`.
        """

class RequestMutUninit:
    r"""
    A version of the `RequestMut` where the payload is not initialized which allows
    true zero copy usage. To send a `RequestMutUninit` it must be first initialized
    and converted into `RequestMut` with `RequestMutUninit::assume_init()`.
    """
    @property
    def __request_payload_type_details(self) -> typing.Optional[typing.Any]: ...
    @property
    def __request_header_type_details(self) -> typing.Optional[typing.Any]: ...
    @property
    def __response_payload_type_details(self) -> typing.Optional[typing.Any]: ...
    @property
    def __response_header_type_details(self) -> typing.Optional[typing.Any]: ...
    @property
    def __slice_len(self) -> builtins.int: ...
    @property
    def header(self) -> RequestHeader:
        r"""
        Returns the iceoryx2 internal `RequestHeader`
        """
    @property
    def user_header_ptr(self) -> builtins.int:
        r"""
        Returns a pointer to the user defined request header.
        """
    @property
    def payload_ptr(self) -> builtins.int:
        r"""
        Returns a pointer to the user defined request payload.
        """
    def delete(self) -> None:
        r"""
        Releases the `RequestMutUninit`.
        
        After this call the `RequestMutUninit` is no longer usable!
        """
    def assume_init(self) -> RequestMut:
        r"""
        When the payload is manually populated by using
        `RequestMutUninit::payload_ptr()`, then this function can be used
        to convert it into the initialized `RequestMut` version.
        """

class RequestResponse:
    r"""
    Default settings for the request response messaging pattern. These settings are used unless
    the user specifies custom QoS or port settings.
    """
    @property
    def enable_safe_overflow_for_requests(self) -> builtins.bool:
        r"""
        Defines if the request buffer of the `Service` safely overflows.
        """
    @property
    def enable_safe_overflow_for_responses(self) -> builtins.bool:
        r"""
        Defines if the response buffer of the `Service` safely overflows.
        """
    @property
    def max_active_requests_per_client(self) -> builtins.int:
        r"""
        The maximum of `ActiveRequest`s a `Server` can hold in
        parallel per `Client`.
        """
    @property
    def max_response_buffer_size(self) -> builtins.int:
        r"""
        The maximum buffer size for `Response`s for a
        `PendingResponse`.
        """
    @property
    def max_servers(self) -> builtins.int:
        r"""
        The maximum amount of supported `Server`
        """
    @property
    def max_clients(self) -> builtins.int:
        r"""
        The maximum amount of supported `Client`
        """
    @property
    def max_nodes(self) -> builtins.int:
        r"""
        The maximum amount of supported `Node`s. Defines
        indirectly how many processes can open the service at the same time.
        """
    @property
    def max_borrowed_responses_per_pending_response(self) -> builtins.int:
        r"""
        The maximum amount of borrowed `Response` per
        `PendingResponse` on the `Client` side.
        """
    @property
    def max_loaned_requests(self) -> builtins.int:
        r"""
        Defines how many `RequestMut` a
        `Client` can loan in parallel.
        """
    @property
    def server_max_loaned_responses_per_request(self) -> builtins.int:
        r"""
        Defines how many `ResponseMut` a `Server` can loan in
        parallel per `ActiveRequest`.
        """
    @property
    def client_unable_to_deliver_strategy(self) -> UnableToDeliverStrategy:
        r"""
        Defines the `UnableToDeliverStrategy` when a `Client`
        could not deliver the request to the `Server`.
        """
    @property
    def server_unable_to_deliver_strategy(self) -> UnableToDeliverStrategy:
        r"""
        Defines the `UnableToDeliverStrategy` when a `Server`
        could not deliver the response to the `Client`.
        """
    @property
    def client_expired_connection_buffer(self) -> builtins.int:
        r"""
        Defines the size of the internal `Client`
        buffer that contains expired connections. An
        connection is expired when the `Server`
        disconnected from a service and the connection
        still contains unconsumed `Response`s.
        """
    @property
    def server_expired_connection_buffer(self) -> builtins.int:
        r"""
        Defines the size of the internal `Server`
        buffer that contains expired connections. An
        connection is expired when the `Client`
        disconnected from a service and the connection
        still contains unconsumed `ActiveRequest`s.
        """
    @property
    def enable_fire_and_forget_requests(self) -> builtins.bool:
        r"""
        Allows the `Server` to receive `RequestMut`s of `Client`s that are not interested in a
        `Response`, meaning that the `Server` will receive the `RequestMut` despite the
        corresponding `PendingResponse` already went out-of-scope. So any `Response` sent by the
        `Server` would not be received by the corresponding `Client`s `PendingResponse`.
        
        Consider enabling this feature if you do not want to loose any `RequestMut`.
        """
    @enable_safe_overflow_for_requests.setter
    def enable_safe_overflow_for_requests(self, value: builtins.bool) -> None:
        r"""
        Enables/disables safe overflow for the request buffer.
        """
    @enable_safe_overflow_for_responses.setter
    def enable_safe_overflow_for_responses(self, value: builtins.bool) -> None:
        r"""
        Enables/disables safe overflow for the response buffer.
        """
    @max_active_requests_per_client.setter
    def max_active_requests_per_client(self, value: builtins.int) -> None:
        r"""
        Set the maximum of `ActiveRequest`s a `Server` can hold in
        parallel per `Client`.
        """
    @max_response_buffer_size.setter
    def max_response_buffer_size(self, value: builtins.int) -> None:
        r"""
        Set the maximum buffer size for `Response`s for a
        `PendingResponse`.
        """
    @max_servers.setter
    def max_servers(self, value: builtins.int) -> None:
        r"""
        Set the maximum amount of supported `Server`
        """
    @max_clients.setter
    def max_clients(self, value: builtins.int) -> None:
        r"""
        Set the maximum amount of supported `Client`
        """
    @max_nodes.setter
    def max_nodes(self, value: builtins.int) -> None:
        r"""
        Set the maximum amount of supported `Node`s. Defines
        indirectly how many processes can open the service at the same time.
        """
    @max_borrowed_responses_per_pending_response.setter
    def max_borrowed_responses_per_pending_response(self, value: builtins.int) -> None:
        r"""
        Set the maximum amount of borrowed `Response` per
        `PendingResponse` on the `Client` side.
        """
    @max_loaned_requests.setter
    def max_loaned_requests(self, value: builtins.int) -> None:
        r"""
        Set how many `RequestMut` a
        `Client` can loan in parallel.
        """
    @server_max_loaned_responses_per_request.setter
    def server_max_loaned_responses_per_request(self, value: builtins.int) -> None:
        r"""
        Set how many `ResponseMut` a `Server` can loan in
        parallel per `ActiveRequest`.
        """
    @client_unable_to_deliver_strategy.setter
    def client_unable_to_deliver_strategy(self, value: UnableToDeliverStrategy) -> None:
        r"""
        Set the `UnableToDeliverStrategy` when a `Client`
        could not deliver the request to the `Server`.
        """
    @server_unable_to_deliver_strategy.setter
    def server_unable_to_deliver_strategy(self, value: UnableToDeliverStrategy) -> None:
        r"""
        Set the `UnableToDeliverStrategy` when a `Server`
        could not deliver the response to the `Client`.
        """
    @client_expired_connection_buffer.setter
    def client_expired_connection_buffer(self, value: builtins.int) -> None:
        r"""
        Set the size of the internal `Client`
        buffer that contains expired connections. An
        connection is expired when the `Server`
        disconnected from a service and the connection
        still contains unconsumed `Response`s.
        """
    @server_expired_connection_buffer.setter
    def server_expired_connection_buffer(self, value: builtins.int) -> None:
        r"""
        Set the size of the internal `Server`
        buffer that contains expired connections. An
        connection is expired when the `Client`
        disconnected from a service and the connection
        still contains unconsumed `ActiveRequest`s.
        """
    @enable_fire_and_forget_requests.setter
    def enable_fire_and_forget_requests(self, value: builtins.bool) -> None:
        r"""
        Set if fire-and-forget feature is enabled
        """
    def __str__(self) -> builtins.str: ...

class Response:
    r"""
    It stores the payload and can be received by the `PendingResponse` after a `RequestMut` was
    sent to a `Server` via the `Client`.
    """
    @property
    def __response_payload_type_details(self) -> typing.Optional[typing.Any]: ...
    @property
    def __response_header_type_details(self) -> typing.Optional[typing.Any]: ...
    @property
    def __slice_len(self) -> builtins.int: ...
    @property
    def header(self) -> ResponseHeader:
        r"""
        Returns the `ResponseHeader`
        """
    @property
    def user_header_ptr(self) -> builtins.int:
        r"""
        Returns a pointer to the user header of the response.
        """
    @property
    def payload_ptr(self) -> builtins.int:
        r"""
        Returns a pointer to the payload of the response.
        """
    @property
    def origin(self) -> UniqueServerId:
        r"""
        Returns the `UniqueServerId` of the `Server` which sent the `Response`.
        """
    def delete(self) -> None:
        r"""
        Releases the `Response`.
        
        After this call the `Response` is no longer usable!
        """

class ResponseHeader:
    r"""
    Response header used by `MessagingPattern::RequestResponse`
    """
    @property
    def server_id(self) -> UniqueServerId:
        r"""
        Returns the `UniqueServerId` of the `Server` which sent the `Response`
        """
    @property
    def number_of_elements(self) -> builtins.int:
        r"""
        Returns how many elements are stored inside the `Response`s payload.
        """

class ResponseMut:
    @property
    def __response_payload_type_details(self) -> typing.Optional[typing.Any]: ...
    @property
    def __response_header_type_details(self) -> typing.Optional[typing.Any]: ...
    @property
    def __slice_len(self) -> builtins.int: ...
    @property
    def header(self) -> ResponseHeader:
        r"""
        Returns a reference to the `ResponseHeader`.
        """
    @property
    def user_header_ptr(self) -> builtins.int:
        r"""
        Returns a pointer to the user header of the response.
        """
    @property
    def payload_ptr(self) -> builtins.int:
        r"""
        Returns a pointer to the payload of the response.
        """
    def delete(self) -> None:
        r"""
        Releases the `ResponseMut`.
        
        After this call the `ResponseMut` is no longer usable!
        """
    def send(self) -> None:
        r"""
        Sends a `ResponseMut` to the corresponding `PendingResponse` of the
        `Client`.
        """

class ResponseMutUninit:
    r"""
    Acquired by a `ActiveRequest` with
     * `ActiveRequest::loan_uninit()`
    
    It stores the payload of the response that will be sent to the corresponding
    `PendingResponse` of the `Client`.
    
    If the `ResponseMutUninit` is not sent it will reelase the loaned memory when going out of
    scope.
    """
    @property
    def __response_payload_type_details(self) -> typing.Optional[typing.Any]: ...
    @property
    def __response_header_type_details(self) -> typing.Optional[typing.Any]: ...
    @property
    def __slice_len(self) -> builtins.int: ...
    @property
    def header(self) -> ResponseHeader:
        r"""
        Returns a reference to the `ResponseHeader`.
        """
    @property
    def user_header_ptr(self) -> builtins.int:
        r"""
        Returns a pointer to the user header of the response.
        """
    @property
    def payload_ptr(self) -> builtins.int:
        r"""
        Returns a pointer to the payload of the response.
        """
    def delete(self) -> None:
        r"""
        Releases the `ResponseMutUninit`.
        
        After this call the `ResponseMutUninit` is no longer usable!
        """
    def assume_init(self) -> ResponseMut:
        r"""
        Converts the `ResponseMutUninit` into `ResponseMut`. This shall be done after the
        payload was written into the `ResponseMutUninit`.
        """

class Sample:
    r"""
    It stores the payload and is acquired by the `Subscriber` whenever
    it receives new data from a `Publisher` via `Subscriber::receive()`.
    """
    @property
    def __payload_type_details(self) -> typing.Optional[typing.Any]: ...
    @property
    def __user_header_type_details(self) -> typing.Optional[typing.Any]: ...
    @property
    def __slice_len(self) -> builtins.int: ...
    @property
    def header(self) -> HeaderPublishSubscribe:
        r"""
        Returns the `HeaderPublishSubscribe` of the `Sample`.
        """
    @property
    def user_header_ptr(self) -> builtins.int:
        r"""
        Returns a pointer to the user header.
        """
    @property
    def payload_ptr(self) -> builtins.int:
        r"""
        Returns a pointer to the payload.
        """
    def delete(self) -> None:
        r"""
        Releases the `Sample`.
        
        After this call the `Sample` is no longer usable!
        """

class SampleMut:
    r"""
    Acquired by a `Publisher` via
     * `Publisher::loan()`,
     * `Publisher::loan_slice()`
    
    It stores the payload that will be sent
    to all connected `Subscriber`s. If the `SampleMut` is not sent
    it will release the loaned memory when going out of scope.
    """
    @property
    def __payload_type_details(self) -> typing.Optional[typing.Any]: ...
    @property
    def __user_header_type_details(self) -> typing.Optional[typing.Any]: ...
    @property
    def __slice_len(self) -> builtins.int: ...
    @property
    def header(self) -> HeaderPublishSubscribe:
        r"""
        Returns the `HeaderPublishSubscribe` of the `Sample`.
        """
    @property
    def user_header_ptr(self) -> builtins.int:
        r"""
        Returns a pointer to the user header.
        """
    @property
    def payload_ptr(self) -> builtins.int:
        r"""
        Returns a pointer to the payload.
        """
    def delete(self) -> None:
        r"""
        Releases the `SampleMut`.
        
        After this call the `SampleMut` is no longer usable!
        """
    def send(self) -> builtins.int:
        r"""
        Send a previously loaned `Publisher::loan_uninit()` `SampleMut` to all connected
        `Subscriber`s of the service.
        
        On success the number of `Subscriber`s that received
        the data is returned, otherwise a `SendError` is emitted describing the failure.
        """

class SampleMutUninit:
    r"""
    Acquired by a `Publisher` via
     * `Publisher::loan_uninit()`
    
    It stores the payload that will be sent
    to all connected `Subscriber`s. If the `SampleMut` is not sent
    it will release the loaned memory when going out of scope.
    """
    @property
    def __payload_type_details(self) -> typing.Optional[typing.Any]: ...
    @property
    def __user_header_type_details(self) -> typing.Optional[typing.Any]: ...
    @property
    def __slice_len(self) -> builtins.int: ...
    @property
    def header(self) -> HeaderPublishSubscribe:
        r"""
        Returns the `HeaderPublishSubscribe` of the `Sample`.
        """
    @property
    def user_header_ptr(self) -> builtins.int:
        r"""
        Returns a pointer to the user header.
        """
    @property
    def payload_ptr(self) -> builtins.int:
        r"""
        Returns a pointer to the payload.
        """
    def delete(self) -> None:
        r"""
        Releases the `SampleMutUninit`.
        
        After this call the `SampleMutUninit` is no longer usable!
        """
    def assume_init(self) -> SampleMut:
        r"""
        Extracts the value of the uninitialized payload and labels the `SampleMutUninit` as
        initialized `SampleMut`
        
        After this call the `SampleMutUninit` is no longer usable!
        """

class Server:
    r"""
    Represents the receiving endpoint of an event based communication.
    """
    @property
    def __request_payload_type_details(self) -> typing.Optional[typing.Any]: ...
    @property
    def __request_header_type_details(self) -> typing.Optional[typing.Any]: ...
    @property
    def __response_payload_type_details(self) -> typing.Optional[typing.Any]: ...
    @property
    def __response_header_type_details(self) -> typing.Optional[typing.Any]: ...
    @property
    def id(self) -> UniqueServerId:
        r"""
        Returns the `UniqueServerId` of the `Server`
        """
    @property
    def has_requests(self) -> builtins.bool:
        r"""
        Returns true if the `Server` has `RequestMut`s in its buffer.
        """
    @property
    def __initial_max_slice_len(self) -> builtins.int:
        r"""
        Returns the maximum initial slice length configured for this `Server`.
        """
    @property
    def unable_to_deliver_strategy(self) -> UnableToDeliverStrategy:
        r"""
        Returns the strategy the `Server` follows when a `ResponseMut` cannot be delivered
        if the `Client`s buffer is full.
        """
    def receive(self) -> typing.Optional[ActiveRequest]:
        r"""
        Receives a `RequestMut` that was sent by a `Client` and returns an `ActiveRequest`
        which can be used to respond. If no `RequestMut`s were received it returns `None`.
        """
    def delete(self) -> None:
        r"""
        Releases the `Server`.
        
        After this call the `Server` is no longer usable!
        """

class Service:
    r"""
    All configurable settings of a `Service`.
    """
    @property
    def directory(self) -> Path:
        r"""
        The directory in which all service files are stored
        """
    @property
    def data_segment_suffix(self) -> FileName:
        r"""
        The suffix of the ports data segment
        """
    @property
    def static_config_storage_suffix(self) -> FileName:
        r"""
        The suffix of the static config file
        """
    @property
    def dynamic_config_storage_suffix(self) -> FileName:
        r"""
        The suffix of the dynamic config file
        """
    @property
    def creation_timeout(self) -> Duration:
        r"""
        Defines the time of how long another process will wait until the service creation is
        finalized
        """
    @property
    def connection_suffix(self) -> FileName:
        r"""
        The suffix of a one-to-one connection
        """
    @property
    def event_connection_suffix(self) -> FileName:
        r"""
        The suffix of a one-to-one connection
        """
    @directory.setter
    def directory(self, value: Path) -> None:
        r"""
        Set the directory in which all service files are stored
        """
    @data_segment_suffix.setter
    def data_segment_suffix(self, value: FileName) -> None:
        r"""
        Set the suffix of the ports data segment
        """
    @static_config_storage_suffix.setter
    def static_config_storage_suffix(self, value: FileName) -> None:
        r"""
        Set the suffix of the static config file
        """
    @dynamic_config_storage_suffix.setter
    def dynamic_config_storage_suffix(self, value: FileName) -> None:
        r"""
        Set the suffix of the dynamic config file
        """
    @creation_timeout.setter
    def creation_timeout(self, value: Duration) -> None:
        r"""
        Set the creation timeout
        """
    @connection_suffix.setter
    def connection_suffix(self, value: FileName) -> None:
        r"""
        Set the suffix of a one-to-one connection
        """
    @event_connection_suffix.setter
    def event_connection_suffix(self, value: FileName) -> None:
        r"""
        Set the suffix of a one-to-one connection
        """
    def __str__(self) -> builtins.str: ...

class Service:
    r"""
    Builder to create or open `Service`s
    """
    @staticmethod
    def does_exist(service_name:ServiceName, config:Config, messaging_pattern:MessagingPattern, service_type:ServiceType) -> builtins.bool:
        r"""
        Checks if a service under a given `Config` does exist
        """
    @staticmethod
    def details(service_name:ServiceName, config:Config, messaging_pattern:MessagingPattern, service_type:ServiceType) -> typing.Optional[ServiceDetails]:
        r"""
        Acquires the `ServiceDetails` of a `Service`.
        """
    @staticmethod
    def list(config:Config, service_type:ServiceType) -> builtins.list[ServiceDetails]:
        r"""
        Returns a list of all services created under a given `Config`.
        """

class ServiceBuilder:
    r"""
    Builder to create or open `Service`s
    """
    def event(self) -> ServiceBuilderEvent:
        r"""
        Create a new builder to create a `MessagingPattern::Event` `Service`.
        """
    def __publish_subscribe(self) -> ServiceBuilderPublishSubscribe:
        r"""
        Create a new builder to create a `MessagingPattern::PublishSubscribe` `Service`.
        """
    def __request_response(self) -> ServiceBuilderRequestResponse:
        r"""
        Create a new builder to create a `MessagingPattern::RequestResponse` `Service`.
        """

class ServiceBuilderEvent:
    r"""
    Builder to create new `MessagingPattern::Event` based `Service`s
    """
    def deadline(self, deadline:Duration) -> ServiceBuilderEvent:
        r"""
        Enables the deadline property of the service. There must be a notification emitted by any
        `Notifier` after at least the provided `deadline`.
        """
    def disable_deadline(self) -> ServiceBuilderEvent:
        r"""
        Disables the deadline property of the service. `Notifier` can signal notifications at any
        rate.
        """
    def max_nodes(self, value:builtins.int) -> ServiceBuilderEvent:
        r"""
        If the `Service` is created it defines how many `Node`s shall be able to open it in
        parallel. If an existing `Service` is opened it defines how many `Node`s must be at least
        supported.
        """
    def event_id_max_value(self, value:builtins.int) -> ServiceBuilderEvent:
        r"""
        If the `Service` is created it set the greatest supported `NodeId` value
        If an existing `Service` is opened it defines the value size the `NodeId`
        must at least support.
        """
    def max_notifiers(self, value:builtins.int) -> ServiceBuilderEvent:
        r"""
        If the `Service` is created it defines how many `Notifier` shall be supported at most. If
        an existing `Service` is opened it defines how many `Notifier` must be at least supported.
        """
    def max_listeners(self, value:builtins.int) -> ServiceBuilderEvent:
        r"""
        If the `Service` is created it defines how many `Listener` shall be supported at most. If
        an existing `Service` is opened it defines how many `Listener` must be at least supported.
        """
    def notifier_created_event(self, value:EventId) -> ServiceBuilderEvent:
        r"""
        If the `Service` is created it defines the event that shall be emitted by every newly
        created `Notifier`.
        """
    def disable_notifier_created_event(self) -> ServiceBuilderEvent:
        r"""
        If the `Service` is created it disables the event that shall be emitted by every newly
        created `Notifier`.
        """
    def notifier_dropped_event(self, value:EventId) -> ServiceBuilderEvent:
        r"""
        If the `Service` is created it defines the event that shall be emitted by every
        `Notifier` before it is dropped.
        """
    def disable_notifier_dropped_event(self) -> ServiceBuilderEvent:
        r"""
        If the `Service` is created it disables the event that shall be emitted by every
        `Notifier` before it is dropped.
        """
    def notifier_dead_event(self, value:EventId) -> ServiceBuilderEvent:
        r"""
        If the `Service` is created it defines the event that shall be emitted when a
        `Notifier` is identified as dead.
        """
    def disable_notifier_dead_event(self) -> ServiceBuilderEvent:
        r"""
        If the `Service` is created it disables the event that shall be emitted when a
        `Notifier` is identified as dead.
        """
    def open_or_create(self) -> PortFactoryEvent:
        r"""
        If the `Service` exists, it will be opened otherwise a new `Service` will be
        created. On failure it emits an `EventOpenOrCreateError`
        """
    def open_or_create_with_attributes(self, verifier:AttributeVerifier) -> PortFactoryEvent:
        r"""
        If the `Service` exists, it will be opened otherwise a new `Service` will be
        created. It defines a set of attributes. If the `Service` already exists all attribute
        requirements must be satisfied otherwise the open process will fail. If the `Service`
        does not exist the required attributes will be defined in the `Service`.
        Emits and `EventOpenOrCreateError` on failure.
        """
    def open(self) -> PortFactoryEvent:
        r"""
        Opens an existing `Service`. Emits an `EventOpenError` on failure.
        """
    def open_with_attributes(self, verifier:AttributeVerifier) -> PortFactoryEvent:
        r"""
        Opens an existing `Service` with attribute requirements. If the defined attribute
        requirements are not satisfied the open process will fail. Emits an `EventOpenError`
        on failure.
        """
    def create(self) -> PortFactoryEvent:
        r"""
        Creates a new `Service`.
        """
    def create_with_attributes(self, attributes:AttributeSpecifier) -> PortFactoryEvent:
        r"""
        Creates a new `Service` with a set of attributes.
        """

class ServiceBuilderPublishSubscribe:
    r"""
    Builder to create new `MessagingPattern::PublishSubscribe` based `Service`s
    """
    def __set_payload_type(self, value:typing.Any) -> None: ...
    def __set_user_header_type(self, value:typing.Any) -> None: ...
    def __payload_type_details(self, value:TypeDetail) -> ServiceBuilderPublishSubscribe:
        r"""
        Defines the payload type. To be able to connect to a `Service` the `TypeDetail` must be
        identical in all participants since the communication is always strongly typed.
        """
    def __user_header_type_details(self, value:TypeDetail) -> ServiceBuilderPublishSubscribe:
        r"""
        Defines the user header type. To be able to connect to a `Service` the `TypeDetail` must be
        identical in all participants since the communication is always strongly typed.
        """
    def payload_alignment(self, value:Alignment) -> ServiceBuilderPublishSubscribe:
        r"""
        Overrides and increases the alignment of the payload - useful when the payload is used in
        SIMD operations. To be able to connect to a `Service` the payload alignment must be
        identical in all participants since the communication is always strongly typed.
        """
    def enable_safe_overflow(self, value:builtins.bool) -> ServiceBuilderPublishSubscribe:
        r"""
        If the `Service` is created, defines the overflow behavior of the service. If an existing
        `Service` is opened it requires the service to have the defined overflow behavior.
        """
    def subscriber_max_borrowed_samples(self, value:builtins.int) -> ServiceBuilderPublishSubscribe:
        r"""
        If the `Service` is created it defines how many `Sample`s a
        `Subscriber` can borrow at most in parallel. If an existing
        `Service` is opened it defines the minimum required.
        """
    def history_size(self, value:builtins.int) -> ServiceBuilderPublishSubscribe:
        r"""
        If the `Service` is created it defines the maximum history size a `Subscriber` can request
        on connection. If an existing `Service` is opened it defines the minimum required.
        """
    def subscriber_max_buffer_size(self, value:builtins.int) -> ServiceBuilderPublishSubscribe:
        r"""
        If the `Service` is created it defines how many `Sample` a `Subscriber` can store in its
        internal buffer. If an existing `Service` is opened it defines the minimum required.
        """
    def max_subscribers(self, value:builtins.int) -> ServiceBuilderPublishSubscribe:
        r"""
        If the `Service` is created it defines how many `Subscriber` shall be supported at
        most. If an existing `Service` is opened it defines how many `Subscriber` must be at
        least supported.
        """
    def max_publishers(self, value:builtins.int) -> ServiceBuilderPublishSubscribe:
        r"""
        If the `Service` is created it defines how many `Publisher` shall be supported at
        most. If an existing `Service` is opened it defines how many `Publisher` must be at
        least supported.
        """
    def max_nodes(self, value:builtins.int) -> ServiceBuilderPublishSubscribe:
        r"""
        If the `Service` is created it defines how many `Node`s shall be able to open it in
        parallel. If an existing `Service` is opened it defines how many `Node`s must be at
        least supported.
        """
    def open_or_create(self) -> PortFactoryPublishSubscribe:
        r"""
        If the `Service` exists, it will be opened otherwise a new `Service` will be created.
        On failure it emits `PublishSubscribeOpenOrCreateError`
        """
    def open_or_create_with_attributes(self, verifier:AttributeVerifier) -> PortFactoryPublishSubscribe:
        r"""
        If the `Service` exists, it will be opened otherwise a new `Service` will be
        created. It defines a set of attributes. If the `Service` already exists all attribute
        requirements must be satisfied otherwise the open process will fail. If the `Service`
        does not exist the required attributes will be defined in the `Service`.
        On failure it emits `PublishSubscribeOpenOrCreateError`
        """
    def open(self) -> PortFactoryPublishSubscribe:
        r"""
        Opens an existing `Service`.
        On failure it emits `PublishSubscribeOpenError`.
        """
    def open_with_attributes(self, verifier:AttributeVerifier) -> PortFactoryPublishSubscribe:
        r"""
        Opens an existing `Service` with attribute requirements. If the defined attribute
        requirements are not satisfied the open process will fail.
        On failure it emits `PublishSubscribeOpenError`.
        """
    def create(self) -> PortFactoryPublishSubscribe:
        r"""
        Creates a new `Service`.
        On failure it emits `PublishSubscribeCreateError`.
        """
    def create_with_attributes(self, attributes:AttributeSpecifier) -> PortFactoryPublishSubscribe:
        r"""
        Creates a new `Service` with a set of attributes.
        On failure it emits `PublishSubscribeCreateError`.
        """

class ServiceBuilderRequestResponse:
    r"""
    Builder to create new `MessagingPattern::RequestResponse` based `Service`s
    """
    def __set_request_payload_type(self, value:typing.Any) -> None: ...
    def __set_response_payload_type(self, value:typing.Any) -> None: ...
    def __set_request_header_type(self, value:typing.Any) -> None: ...
    def __set_response_header_type(self, value:typing.Any) -> None: ...
    def __request_payload_type_details(self, value:TypeDetail) -> ServiceBuilderRequestResponse:
        r"""
        Defines the payload type for requests. To be able to connect to a `Service` the
        `TypeDetail` must be identical in all participants since the communication is always
        strongly typed.
        """
    def __request_header_type_details(self, value:TypeDetail) -> ServiceBuilderRequestResponse:
        r"""
        Defines the request header type. To be able to connect to a `Service` the `TypeDetail` must
        be identical in all participants since the communication is always strongly typed.
        """
    def __response_payload_type_details(self, value:TypeDetail) -> ServiceBuilderRequestResponse:
        r"""
        Defines the payload type for responses. To be able to connect to a `Service` the
        `TypeDetail` must be identical in all participants since the communication is always
        strongly typed.
        """
    def __response_header_type_details(self, value:TypeDetail) -> ServiceBuilderRequestResponse:
        r"""
        Defines the response header type. To be able to connect to a `Service` the `TypeDetail`
        must be identical in all participants since the communication is always strongly typed.
        """
    def request_payload_alignment(self, value:Alignment) -> ServiceBuilderRequestResponse:
        r"""
        Overrides and increases the alignment of the request payload - useful when the payload is
        used in SIMD operations. To be able to connect to a `Service` the payload alignment must be
        identical in all participants since the communication is always strongly typed.
        """
    def response_payload_alignment(self, value:Alignment) -> ServiceBuilderRequestResponse:
        r"""
        Overrides and increases the alignment of the response payload - useful when the payload is
        used in SIMD operations. To be able to connect to a `Service` the payload alignment must be
        identical in all participants since the communication is always strongly typed.
        """
    def enable_safe_overflow_for_requests(self, value:builtins.bool) -> ServiceBuilderRequestResponse:
        r"""
        If the `Service` is created, defines the overflow behavior of the service for requests.
        If an existing `Service` is opened it requires the service to have the defined overflow
        behavior.
        """
    def enable_safe_overflow_for_responses(self, value:builtins.bool) -> ServiceBuilderRequestResponse:
        r"""
        If the `Service` is created, defines the overflow behavior of the service for responses.
        If an existing `Service` is opened it requires the service to have the defined overflow
        behavior.
        """
    def enable_fire_and_forget_requests(self, value:builtins.bool) -> ServiceBuilderRequestResponse:
        r"""
        If the `Service` is created, defines the fire-and-forget behavior of the service for
        requests.
        """
    def max_active_requests_per_client(self, value:builtins.int) -> ServiceBuilderRequestResponse:
        r"""
        Defines how many active requests a `Server` can hold in
        parallel per `Client`. The objects are used to send answers to a request that was
        received earlier from a `Client`.
        """
    def max_loaned_requests(self, value:builtins.int) -> ServiceBuilderRequestResponse:
        r"""
        If the `Service` is created it defines how many `RequestMut` a
        `Client` can loan in parallel.
        """
    def max_response_buffer_size(self, value:builtins.int) -> ServiceBuilderRequestResponse:
        r"""
        If the `Service` is created it defines how many responses fit in the
        `Clients`s buffer. If an existing `Service` is opened it defines the minimum required.
        """
    def max_servers(self, value:builtins.int) -> ServiceBuilderRequestResponse:
        r"""
        If the `Service` is created it defines how many `Server`s shall
        be supported at most. If an existing `Service` is opened it defines how many
        `Server`s must be at least supported.
        """
    def max_clients(self, value:builtins.int) -> ServiceBuilderRequestResponse:
        r"""
        If the `Service` is created it defines how many `Client`s shall
        be supported at most. If an existing `Service` is opened it defines how many
        `Client`s must be at least supported.
        """
    def max_nodes(self, value:builtins.int) -> ServiceBuilderRequestResponse:
        r"""
        If the `Service` is created it defines how many `Node`s shall
        be able to open it in parallel. If an existing `Service` is opened it defines how many
        `Node`s must be at least supported.
        """
    def max_borrowed_responses_per_pending_response(self, value:builtins.int) -> ServiceBuilderRequestResponse:
        r"""
        If the `Service` is created it defines how many `Response`s shall
        be able to be borrowed in parallel per `PendingResponse`. If an
        existing `Service` is opened it defines how many borrows must be at least supported.
        """
    def open_or_create(self) -> PortFactoryRequestResponse:
        r"""
        If the `Service` exists, it will be opened otherwise a new `Service` will be created.
        On failure `RequestResponseOpenOrCreateError` will be emitted.
        """
    def open_or_create_with_attributes(self, verifier:AttributeVerifier) -> PortFactoryRequestResponse:
        r"""
        If the `Service` exists, it will be opened otherwise a new `Service` will be
        created. It defines a set of attributes.
        
        If the `Service` already exists all attribute requirements must be satisfied,
        and service payload type must be the same, otherwise the open process will fail.
        If the `Service` does not exist the required attributes will be defined in the `Service`.
        On failure `RequestResponseOpenOrCreateError` will be emitted.
        """
    def open(self) -> PortFactoryRequestResponse:
        r"""
        Opens an existing `Service`.
        On failure `RequestResponseOpenError` will be emitted.
        """
    def open_with_attributes(self, verifier:AttributeVerifier) -> PortFactoryRequestResponse:
        r"""
        Opens an existing `Service` with attribute requirements. If the defined attribute
        requirements are not satisfied the open process will fail.
        On failure `RequestResponseOpenError` will be emitted.
        """
    def create(self) -> PortFactoryRequestResponse:
        r"""
        Creates a new `Service`.
        On failure `RequestResponseCreateError` will be emitted.
        """
    def create_with_attributes(self, attributes:AttributeSpecifier) -> PortFactoryRequestResponse:
        r"""
        Creates a new `Service` with a set of attributes.
        On failure `RequestResponseCreateError` will be emitted.
        """

class ServiceDetails:
    r"""
    Represents all the `Service` information that one can acquire with `Service::list()`.
    """
    def nodes(self) -> builtins.list[NodeState]:
        r"""
        A list of all `Node`s that are registered at the `Service`
        """
    def attributes(self) -> AttributeSet:
        r"""
        Returns the attributes of the `Service`
        """
    def service_id(self) -> ServiceId:
        r"""
        Returns the unique `ServiceId` of the `Service`
        """
    def name(self) -> ServiceName:
        r"""
        Returns the `ServiceName`
        """
    def messaging_pattern(self) -> MessagingPattern:
        r"""
        Returns the `Service`s underlying `MessagingPattern`.
        """

class ServiceId:
    r"""
    The unique id of a `Service`
    """
    @property
    def as_str(self) -> builtins.str:
        r"""
        Returns a String containing the `ServiceId` value
        """
    @staticmethod
    def max_number_of_characters() -> builtins.int:
        r"""
        Returns the maximum string length of a `ServiceId`
        """

class ServiceName:
    r"""
    Relocatable (inter-process shared memory compatible) `SemanticString` implementation for
    `ServiceName`. All modification operations ensure that never an
    invalid file or path name can be generated. All strings have a fixed size so that the maximum
    path or file name length the system supports can be stored.
    """
    @staticmethod
    def new(name:builtins.str) -> ServiceName:
        r"""
        Creates a new `ServiceName` when the provided `name` contains a valid path to a file,
        otherwise it emits a `SemanticStringError`.
        """
    @staticmethod
    def max_len() -> builtins.int:
        r"""
        Returns the maximum length of a `ServiceName`
        """
    def to_string(self) -> builtins.str:
        r"""
        Converts the `ServiceName` into a `String`
        """

class StaticConfigEvent:
    r"""
    The static configuration of an `MessagingPattern::Event`
    based service. Contains all parameters that do not change during the lifetime of a
    `Service`.
    """
    @property
    def deadline(self) -> typing.Optional[Duration]:
        r"""
        Returns the deadline of the service. If no new notification is signaled from any
        `Notifier` after the given deadline, it is rated as an error and all `Listener`s that are
        attached to a `WaitSet` are woken up and notified about the missed
        """
    @property
    def max_nodes(self) -> builtins.int:
        r"""
        Returns the maximum supported amount of `Node`s that can open the `Service` in parallel.
        """
    @property
    def max_notifiers(self) -> builtins.int:
        r"""
        Returns the maximum supported amount of `Notifier` ports
        """
    @property
    def max_listeners(self) -> builtins.int:
        r"""
        Returns the maximum supported amount of `Listener` ports
        """
    @property
    def event_id_max_value(self) -> builtins.int:
        r"""
        Returns the largest `EventId` that is supported by the service
        """
    @property
    def notifier_created_event(self) -> typing.Optional[EventId]:
        r"""
        Returns the emitted `EventId` when a new notifier is created.
        """
    @property
    def notifier_dropped_event(self) -> typing.Optional[EventId]:
        r"""
        Returns the emitted `EventId` when a notifier is dropped.
        """
    @property
    def notifier_dead_event(self) -> typing.Optional[EventId]:
        r"""
        Returns the emitted `EventId` when a notifier is identified as dead.
        """

class StaticConfigPublishSubscribe:
    r"""
    The static configuration of an `MessagingPattern::PublishSubscribe` based `Service`. Contains
    all parameters that do not change during the lifetime of a `Service`.
    """
    @property
    def max_nodes(self) -> builtins.int:
        r"""
        Returns the maximum supported amount of `Node`s that can open the `Service` in parallel.
        """
    @property
    def max_publishers(self) -> builtins.int:
        r"""
        Returns the maximum supported amount of `Publisher` ports
        """
    @property
    def max_subscribers(self) -> builtins.int:
        r"""
        Returns the maximum supported amount of `Subscriber` ports
        """
    @property
    def history_size(self) -> builtins.int:
        r"""
        Returns the maximum history size that can be requested on connect.
        """
    @property
    def subscriber_max_buffer_size(self) -> builtins.int:
        r"""
        Returns the maximum supported buffer size for `Subscriber` port
        """
    @property
    def subscriber_max_borrowed_samples(self) -> builtins.int:
        r"""
        Returns how many `Sample` a `Subscriber` port can borrow in parallel at most.
        """
    @property
    def has_safe_overflow(self) -> builtins.bool:
        r"""
        Returns true if the `Service` safely overflows, otherwise false. Safe
        overflow means that the `Publisher` will recycle the oldest
        `Sample` from the `Subscriber` when its buffer
        is full.
        """
    @property
    def message_type_details(self) -> MessageTypeDetails:
        r"""
        Returns the type details of the `Service`.
        """

class StaticConfigRequestResponse:
    r"""
    The static configuration of an `MessagingPattern::RequestResponse` based service. Contains all
    parameters that do not change during the lifetime of a `Service`.
    """
    @property
    def request_message_type_details(self) -> MessageTypeDetails:
        r"""
        Returns the request type details of the `Service`.
        """
    @property
    def response_message_type_details(self) -> MessageTypeDetails:
        r"""
        Returns the response type details of the `Service`.
        """
    @property
    def has_safe_overflow_for_requests(self) -> builtins.bool:
        r"""
        Returns true if the request buffer of the `Service` safely overflows, otherwise false.
        Safe overflow means that the `Client` will recycle the oldest requests from the
        `Server` when its buffer is full.
        """
    @property
    def has_safe_overflow_for_responses(self) -> builtins.bool:
        r"""
        Returns true if the response buffer of the `Service` safely overflows, otherwise false.
        Safe overflow means that the `Server` will recycle the oldest responses from the
        `Client` when its buffer is full.
        """
    @property
    def does_support_fire_and_forget_requests(self) -> builtins.bool:
        r"""
        Returns true if fire and forget `RequestMut`s can be sent from the `Client`, otherwise
        false.
        """
    @property
    def max_borrowed_responses_per_pending_response(self) -> builtins.int:
        r"""
        Returns the maximum number of borrowed `Response`s a `Client` can hold in parallel per
        `PendingResponse`
        """
    @property
    def max_active_requests_per_client(self) -> builtins.int:
        r"""
        Returns the maximum of active requests a `Server` can hold in parallel per `Client`.
        """
    @property
    def max_response_buffer_size(self) -> builtins.int:
        r"""
        Returns the maximum buffer size for responses for a `PendingResponse`.
        """
    @property
    def max_loaned_requests(self) -> builtins.int:
        r"""
        Returns the maximum number of `RequestMut` a `Client` can loan in parallel.
        """
    @property
    def max_servers(self) -> builtins.int:
        r"""
        Returns the maximum number of supported `Server` ports for the `Service`.
        """
    @property
    def max_clients(self) -> builtins.int:
        r"""
        Returns the maximum number of supported `Client` ports for the `Service`.
        """
    @property
    def max_nodes(self) -> builtins.int:
        r"""
        Returns the maximum number of supported `Node`s for the `Service`.
        """

class Subscriber:
    r"""
    Represents the receiving endpoint of an event based communication.
    """
    @property
    def id(self) -> UniqueSubscriberId:
        r"""
        Returns the `UniqueSubscriberId` of the `Subscriber`
        """
    @property
    def buffer_size(self) -> builtins.int:
        r"""
        Returns the internal buffer size of the `Subscriber`.
        """
    def has_samples(self) -> builtins.bool:
        r"""
        Returns true if the `Subscriber` has samples in the buffer that can be received with
        `Subscriber::receive`. Emits `ConnectionFailure` on error.
        """
    def receive(self) -> typing.Optional[Sample]:
        r"""
        Receives a `Sample` from `Publisher`. If no sample could be received `None` is returned.
        If a failure occurs `ReceiveError` is returned.
        """
    def delete(self) -> None:
        r"""
        Releases the `Subscriber`.
        
        After this call the `Subscriber` is no longer usable!
        """

class TypeDetail:
    r"""
    Contains all type details required to connect to a `Service`
    """
    @staticmethod
    def new() -> TypeDetail:
        r"""
        Creates a new `TypeDetail` for the unit type. Meaning size == 0, alignment == 1
        """
    def type_variant(self, value:TypeVariant) -> TypeDetail:
        r"""
        Defines the `TypeVariant` of the defined type. `TypeVariant::FixedSize` if the type has
        always the same size like an `uint64_t` or `TypeVariant::Dynamic` when it is a dynamic
        array or vector
        """
    def type_name(self, name:TypeName) -> TypeDetail:
        r"""
        Sets the unique `TypeName` of the type
        """
    def size(self, size:builtins.int) -> TypeDetail:
        r"""
        Sets the size of the type
        """
    def alignment(self, alignment:builtins.int) -> TypeDetail:
        r"""
        Sets the alignment of the type
        """

class TypeName:
    r"""
    Represents the string name of a type. The name shall uniquely identify the type in the
    communication system.
    """
    @staticmethod
    def new(name:builtins.str) -> TypeName:
        r"""
        Creates a new `TypeName`. If the provided `name` exceeds the maximum supported length
        it emits an `SemanticStringError`.
        """
    @staticmethod
    def max_len() -> builtins.int:
        r"""
        The maximum supported length of a `TypeName`
        """
    def to_string(self) -> builtins.str:
        r"""
        Returns the underlying `String` of the `TypeName`
        """

class TypeStorage:
    ...

class UniqueClientId:
    r"""
    The system-wide unique id of a `Client`.
    """
    @property
    def value(self) -> builtins.int:
        r"""
        Returns the underlying raw value of the ID
        """

class UniqueListenerId:
    r"""
    The system-wide unique id of a `Listener`.
    """
    @property
    def value(self) -> builtins.int:
        r"""
        Returns the underlying raw value of the ID
        """

class UniqueNotifierId:
    r"""
    The system-wide unique id of a `Notifier`.
    """
    @property
    def value(self) -> builtins.int:
        r"""
        Returns the underlying raw value of the ID
        """

class UniquePublisherId:
    r"""
    The system-wide unique id of a `Publisher`.
    """
    @property
    def value(self) -> builtins.int:
        r"""
        Returns the underlying raw value of the ID
        """

class UniqueServerId:
    r"""
    The system-wide unique id of a `Server`.
    """
    @property
    def value(self) -> builtins.int:
        r"""
        Returns the underlying raw value of the ID
        """

class UniqueSubscriberId:
    r"""
    The system-wide unique id of a `Subscriber`.
    """
    @property
    def value(self) -> builtins.int:
        r"""
        Returns the underlying raw value of the ID
        """

class WaitSet:
    r"""
    The `WaitSet` implements a reactor pattern and allows to wait on multiple events in one
    single call `WaitSet::wait_and_process()` until a interrupt or termination signal was received.
    
    The `Listener` can be attached as well as sockets or anything else that is a `FileDescriptor`.
    
    Can be created via the `WaitSetBuilder`.
    """
    @property
    def capacity(self) -> builtins.int:
        r"""
        Returns the capacity of the `WaitSet`
        """
    @property
    def len(self) -> builtins.int:
        r"""
        Returns the number of attachments.
        """
    @property
    def is_empty(self) -> builtins.bool:
        r"""
        Returns true if the `WaitSet` has no attachments, otherwise false.
        """
    @property
    def signal_handling_mode(self) -> SignalHandlingMode:
        r"""
        Returns the `SignalHandlingMode` with which the `WaitSet` was created.
        """
    def attach_notification(self, attachment:Listener) -> WaitSetGuard:
        r"""
        Attaches a `Listener` as notification to the `WaitSet`. Whenever an event is received on the
        object the `WaitSet` informs the user in `WaitSet::wait_and_process()` to handle the event.
        The object cannot be attached twice and the
        `WaitSet::capacity()` is limited by the underlying implementation.
        """
    def attach_notification_fd(self, attachment:FileDescriptor) -> WaitSetGuard:
        r"""
        Attaches a `FileDescriptor` as notification to the `WaitSet`. Whenever an event is received on the
        object the `WaitSet` informs the user in `WaitSet::wait_and_process()` to handle the event.
        The object cannot be attached twice and the
        `WaitSet::capacity()` is limited by the underlying implementation.
        """
    def attach_deadline(self, attachment:Listener, deadline:Duration) -> WaitSetGuard:
        r"""
        Attaches a `Listener` as deadline to the `WaitSet`. Whenever the event is received or the
        deadline is hit, the user is informed in `WaitSet::wait_and_process()`.
        The object cannot be attached twice and the
        `WaitSet::capacity()` is limited by the underlying implementation.
        Whenever the object emits an event the deadline is reset by the `WaitSet`.
        """
    def attach_deadline_fd(self, attachment:FileDescriptor, deadline:Duration) -> WaitSetGuard:
        r"""
        Attaches a `FileDescriptor` as deadline to the `WaitSet`. Whenever the event is received or
        the deadline is hit, the user is informed in `WaitSet::wait_and_process()`.
        The object cannot be attached twice and the
        `WaitSet::capacity()` is limited by the underlying implementation.
        Whenever the object emits an event the deadline is reset by the `WaitSet`.
        """
    def attach_interval(self, interval:Duration) -> WaitSetGuard:
        r"""
        Attaches a tick event to the `WaitSet`. Whenever the timeout is reached the `WaitSet`
        informs the user in `WaitSet::wait_and_process()`.
        """
    def wait_and_process(self) -> tuple[builtins.list[WaitSetAttachmentId], WaitSetRunResult]:
        r"""
        Waits until an event arrives on the `WaitSet`, then collects the events corresponding
        `WaitSetAttachmentId` in a vector and returns it.
        
        If an interrupt- (`SIGINT`) or a termination-signal (`SIGTERM`) was received, it will exit
        the loop and inform the user with [`WaitSetRunResult::Interrupt`] or
        [`WaitSetRunResult::TerminationRequest`].
        """
    def wait_and_process_with_timeout(self, timeout:Duration) -> tuple[builtins.list[WaitSetAttachmentId], WaitSetRunResult]:
        r"""
        Waits until an event arrives on the `WaitSet` or the provided timeout has passed, then
        collects the events corresponding `WaitSetAttachmentId` in a vector and returns it.
        
        If an interrupt- (`SIGINT`) or a termination-signal (`SIGTERM`) was received, it will exit
        the loop and inform the user with [`WaitSetRunResult::Interrupt`] or
        [`WaitSetRunResult::TerminationRequest`].
        """

class WaitSetAttachmentId:
    r"""
    Represents an attachment to the `WaitSet`
    """
    @staticmethod
    def from_guard(guard:WaitSetGuard) -> WaitSetAttachmentId:
        r"""
        Creates an `WaitSetAttachmentId` from a `WaitSetGuard` that was returned via
        `WaitSet::attach_interval()`, `WaitSet::attach_notification()` or
        `WaitSet::attach_deadline()`.
        """
    def has_event_from(self, other:WaitSetGuard) -> builtins.bool:
        r"""
        Returns true if an event was emitted from a notification or deadline attachment
        corresponding to `WaitSetGuard`.
        """
    def has_missed_deadline(self, other:WaitSetGuard) -> builtins.bool:
        r"""
        Returns true if the deadline for the attachment corresponding to `WaitSetGuard` was missed.
        """

class WaitSetBuilder:
    r"""
    Creates a new `WaitSet`.
    """
    @staticmethod
    def new() -> WaitSetBuilder:
        r"""
        Instantiates a new `WaitSetBuilder`
        """
    def signal_handling_mode(self, value:SignalHandlingMode) -> WaitSetBuilder:
        r"""
        Defines the `SignalHandlingMode` for the `WaitSet`. It affects the
        `WaitSet::wait_and_process()` and `WaitSet::wait_and_process_once()` calls
        that returns any received `Signal` via its `WaitSetRunResult` return value.
        """
    def create(self, service_type:ServiceType) -> WaitSet:
        r"""
        Creates the `WaitSet`.
        """

class WaitSetGuard:
    r"""
    Is returned when something is attached to the `WaitSet`. As soon as it goes out
    of scope, the attachment is detached.
    """
    def delete(self) -> None:
        r"""
        Drops the `WaitSetGuard`. After this call the `WaitSetGuard` is no longer usable.
        """

class AllocationStrategy(Enum):
    r"""
    Describes generically an `AllocationStrategy`, meaning how the memory is increased when the
    available memory is insufficient.
    """
    BestFit = ...
    r"""
    Increases the memory so that it perfectly fits the new size requirements. This may lead
    to a lot of reallocations but has the benefit that no byte is wasted.
    """
    PowerOfTwo = ...
    r"""
    Increases the memory by rounding the increased memory size up to the next power of two.
    Reduces reallocations a lot at the cost of increased memory usage.
    """
    Static = ...
    r"""
    The memory is not increased. This may lead to an out-of-memory error when allocating.
    """

    def __str__(self) -> builtins.str: ...

class LogLevel(Enum):
    r"""
    Describes the log level.
    """
    Trace = ...
    Debug = ...
    Info = ...
    Warn = ...
    Error = ...
    Fatal = ...

    def __str__(self) -> builtins.str: ...

class MessagingPattern(Enum):
    PublishSubscribe = ...
    Event = ...
    RequestResponse = ...
    Blackboard = ...

    def __str__(self) -> builtins.str: ...

class ServiceType(Enum):
    r"""
    Defines the type of the `Service` and what kind of resources and operating system mechanisms
    it shall use.
    """
    Local = ...
    r"""
    Optimized for inter-thread communication does not not support inter-process communication.
    """
    Ipc = ...
    r"""
    Optimized for inter-process communication.
    """

    def __str__(self) -> builtins.str: ...

class SignalHandlingMode(Enum):
    r"""
    Defines how signals are handled by constructs that might register a custom
    `SignalHandler`
    """
    HandleTerminationRequests = ...
    r"""
    The signals `Signal::Interrupt` and `Signal::Terminate` are registered and
    handled. If such a `Signal` is received the user will be notified.
    """
    Disabled = ...
    r"""
    No signal handler will be registered.
    """

    def __str__(self) -> builtins.str: ...

class TypeVariant(Enum):
    r"""
    Defines if the type is a slice with a runtime-size (`TypeVariant::Dynamic`)
    or if its a type that satisfies `Sized` (`TypeVariant::FixedSize`).
    """
    FixedSize = ...
    r"""
    A fixed size type like `uint64_t`
    """
    Dynamic = ...
    r"""
    A dynamic sized type like a slice (dynamic array)
    """

class UnableToDeliverStrategy(Enum):
    r"""
    Defines the strategy a sender shall pursue when the buffer of the receiver is full
    and the service does not overflow.
    """
    Block = ...
    r"""
    Blocks until the receiver has consumed the
    data from the buffer and there is space again
    """
    DiscardSample = ...
    r"""
    Do not deliver the data.
    """

    def __str__(self) -> builtins.str: ...

class WaitSetRunResult(Enum):
    r"""
    States why the `WaitSet::wait_and_process()` method returned.
    """
    TerminationRequest = ...
    r"""
    A termination signal `SIGTERM` was received.
    """
    Interrupt = ...
    r"""
    An interrupt signal `SIGINT` was received.
    """
    StopRequest = ...
    r"""
    The users callback returned `CallbackProgression::Stop`.
    """
    AllEventsHandled = ...
    r"""
    All events were handled.
    """

    def __str__(self) -> builtins.str: ...

def default() -> Config: ...

def default_config_file_name() -> FileName:
    r"""
    The name of the default iceoryx2 config file
    """

def default_config_file_path() -> FilePath:
    r"""
    Path to the default config file
    """

def default_user_config_file_path() -> FilePath:
    r"""
    Path to the default user config file
    """

def from_file(config_file:FilePath) -> Config:
    r"""
    Loads a configuration from a file. On success it returns a `Config` object otherwise a
    `ConfigCreationError` describing the failure.
    """

def global_config() -> Config: ...

def relative_config_path() -> Path:
    r"""
    Relative path to the config file
    """

def set_log_level(value:LogLevel) -> None:
    r"""
    Sets the current log level. This is ignored for external frameworks like `log` or `tracing`.
    Here you have to use the log-level settings of that framework.
    """

def set_log_level_from_env_or(value:LogLevel) -> None:
    r"""
    Sets the log level by reading environment variable "IOX2_LOG_LEVEL", and if the environment variable
    doesn't exit it sets it with a user-defined logging level
    """

def set_log_level_from_env_or_default() -> None:
    r"""
    Sets the log level by reading environment variable "IOX2_LOG_LEVEL" or default it with LogLevel::INFO
    """

def setup_global_config_from_file(config_file:FilePath) -> Config: ...

