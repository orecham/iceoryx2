name: Documentation

on:
  push:
    branches: [ main ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main, release* ]
    types: [ opened, ready_for_review, reopened, synchronize ]
  schedule:
    # nightly at 02:00 UTC - prevents artifact expiration
    - cron: '0 2 * * *'
  workflow_dispatch:

jobs:

  changes:
    if: github.event.pull_request.draft == false || github.event_name != 'pull_request'
    runs-on: ubuntu-latest
    permissions:
      pull-requests: read
    outputs:
      source-code: ${{ steps.filter.outputs.source-code }}
      api-docs: ${{ steps.filter.outputs.api-docs }}
    steps:
      - name: Checkout sources
        if: github.event_name == 'pull_request'
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683

      - name: Check for changed file types
        if: github.event_name == 'pull_request'
        uses: dorny/paths-filter@de90cc6fb38fc0963ad72b210f1f284cd68cea36
        id: filter
        with:
          filters: |
            source-code:
              - '**'
              - '!**/*.md'
            api-docs:
              - 'doc/api/**/*'

  build-api-reference-python:
    needs: changes
    if: |
      needs.changes.result == 'success' &&
      (github.event_name != 'pull_request' || 
       needs.changes.outputs.source-code == 'true' || 
       needs.changes.outputs.api-docs == 'true')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683

      - name: Prepare Linux
        run: |
          internal/scripts/ci_prepare_ubuntu.sh
          uname -a

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install Poetry
        uses: snok/install-poetry@v1
        with:
          version: 2.1.3

      - name: Build Python Bindings
        run: |
          poetry --project iceoryx2-ffi/python install
          poetry --project iceoryx2-ffi/python build-into-venv

      - name: Build Python API Documentation
        run: |
          poetry --project doc/api/python install
          poetry --project doc/api/python build-docs

      - name: Upload Python Documentation Artifact
        # TODO: Uncomment this condition to skip uploads on pull requests
        # if: github.event_name != 'pull_request'
        uses: actions/upload-artifact@v4
        with:
          name: documentation-api-python-${{ github.sha }}
          path: doc/api/python/target/html
          retention-days: 90

  build-api-reference-c:
    needs: changes
    if: |
      needs.changes.result == 'success' &&
      (github.event_name != 'pull_request' || 
       needs.changes.outputs.source-code == 'true' || 
       needs.changes.outputs.api-docs == 'true')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683

      - name: Prepare Linux
        run: |
          internal/scripts/ci_prepare_ubuntu.sh
          uname -a

      - name: Build C Bindings
        run: |
          cargo build --release --package iceoryx2-ffi-c

      - name: Build C API Documentation
        run: |
          cd doc/api/c && make html && cd -

      - name: Upload C Documentation Artifact
        # TODO: Uncomment this condition to skip uploads on pull requests
        # if: github.event_name != 'pull_request'
        uses: actions/upload-artifact@v4
        with:
          name: documentation-api-c-${{ github.sha }}
          path: doc/api/c/target/html
          retention-days: 90

  build-api-reference-cxx:
    needs: changes
    if: |
      needs.changes.result == 'success' &&
      (github.event_name != 'pull_request' || 
       needs.changes.outputs.source-code == 'true' || 
       needs.changes.outputs.api-docs == 'true')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683

      - name: Prepare Linux
        run: |
          internal/scripts/ci_prepare_ubuntu.sh
          uname -a

      - name: Build C++ API Documentation
        run: |
          cd doc/api/cxx && make html && cd -

      - name: Upload C++ Documentation Artifact
        # TODO: Uncomment this condition to skip uploads on pull requests
        # if: github.event_name != 'pull_request'
        uses: actions/upload-artifact@v4
        with:
          name: documentation-api-cxx-${{ github.sha }}
          path: doc/api/cxx/target/html
          retention-days: 90

  deploy:
    needs: [build-api-reference-python, build-api-reference-c, build-api-reference-cxx]
    # TODO: Uncomment this condition to skip deploy on pull requests
    # if: github.event_name != 'pull_request'
    runs-on: ubuntu-latest
    
    permissions:
      pages: write
      id-token: write
      actions: read

    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}

    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683

      - name: Build and cache tera
        uses: ./.github/actions/build-and-cache-rust-tool
        with:
          rust-toolchain: stable
          check-and-install-cmd: tera --version > /dev/null || cargo install tera-cli --version 0.5.0 --locked
          print-version-cmd: tera --version
          cache-key: cache-1-${{ runner.os }}-tera-cli-0.5.0
          artifact-bin-name: tera
          artifact-upload-name: ${{ runner.os }}-tera-cli

      - name: Find previous successful deployment
        id: find-previous
        run: |
          echo "Looking for most recent successful Pages deployment..."

          # Find successful runs of this workflow
          RUNS=$(gh run list \
            --workflow="${{ github.workflow }}" \
            --status=success \
            --limit=20 \
            --json databaseId)

          FOUND_RUN_ID=""

          # Make sure the artifact exists
          for run_id in $(echo "$RUNS" | jq -r '.[].databaseId'); do
            if [ "$run_id" = "${{ github.run_id }}" ]; then
              continue
            fi

            echo "Checking run $run_id for github-pages artifact..."
            ARTIFACTS=$(gh api "repos/${{ github.repository }}/actions/runs/$run_id/artifacts" --jq '.artifacts[] | select(.name == "github-pages" and .expired == false)')

            if [ -n "$ARTIFACTS" ]; then
              echo "Found valid github-pages artifact in run $run_id"
              FOUND_RUN_ID="$run_id"
              break
            fi
          done

          # Set output
          if [ -n "$FOUND_RUN_ID" ]; then
            echo "Previous deployment found: $FOUND_RUN_ID"
            echo "run-id=$FOUND_RUN_ID" >> $GITHUB_OUTPUT
            echo "found=true" >> $GITHUB_OUTPUT
          else
            echo "No previous deployment found, starting fresh"
            echo "found=false" >> $GITHUB_OUTPUT
          fi
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Download existing GitHub Pages deployment
        if: steps.find-previous.outputs.found == 'true'
        uses: actions/download-artifact@v4
        with:
          name: github-pages
          path: ./old-artifacts
          run-id: ${{ steps.find-previous.outputs.run-id }}
          github-token: ${{ github.token }}

      - name: Download Python documentation artifact
        uses: actions/download-artifact@v4
        with:
          name: documentation-api-python-${{ github.sha }}
          path: ./new-artifacts/python

      - name: Download C documentation artifact
        uses: actions/download-artifact@v4
        with:
          name: documentation-api-c-${{ github.sha }}
          path: ./new-artifacts/c

      - name: Download C++ documentation artifact
        uses: actions/download-artifact@v4
        with:
          name: documentation-api-cxx-${{ github.sha }}
          path: ./new-artifacts/cxx

      - name: Prepare new artifact for GitHub Pages
        run: |
          # Determine version/branch name
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            VERSION="main"
          elif [[ "${{ github.event_name }}" == "schedule" ]]; then
            VERSION="main"
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            VERSION="main"
          elif [[ "${{ github.ref }}" == refs/tags/* ]]; then
            VERSION="${{ github.ref_name }}"
          else
            VERSION="${{ github.ref_name }}"
          fi
          
          echo "Preparing Pages with new artifact for version: $VERSION"

          mkdir -p ./staged-artifacts

          # Retrieve previous artifacts if available
          if [ "${{ steps.find-previous.outputs.found }}" = "true" ] && [ -f "./old-artifacts/artifact.tar" ]; then
            tar -xf ./old-artifacts/artifact.tar -C ./staged-artifacts
            echo "Using old artifacts as starting point"
          else
            echo "No old artifacts found, starting fresh"
          fi

          # Remove existing artifact for this version and create fresh directories
          echo "Setting up directories for version: $VERSION"
          rm -rf "./staged-artifacts/python/$VERSION" "./staged-artifacts/c/$VERSION" "./staged-artifacts/cxx/$VERSION" 2>/dev/null || true
          mkdir -p "./staged-artifacts/python/$VERSION" "./staged-artifacts/c/$VERSION" "./staged-artifacts/cxx/$VERSION"

          # Copy new artifacts
          echo "Staging new artifacts for version: $VERSION"
          cp -r ./new-artifacts/python/* "./staged-artifacts/python/$VERSION/"
          cp -r ./new-artifacts/c/* "./staged-artifacts/c/$VERSION/"
          cp -r ./new-artifacts/cxx/* "./staged-artifacts/cxx/$VERSION/"

      - name: Generate landing page
        run: |
          # Fetch the available Rust documentation
          # NOTE: Since docs.rs blocks github actions from hitting its API,
          # only a link to the latest version is added
          fetch_rust_versions_json() {
            local versions_array='[{
              "name": "docs.rs",
              "url": "https://docs.rs/iceoryx2/latest/iceoryx2/",
              "isLatest": true
            }]'
            
            echo "$versions_array"
          }
          
          # Generate JSON for the available versions in the staged artifacts
          generate_bindings_versions_json() {
            local lang_path=$1
            local versions_array="[]"
            
            if [ -d "./staged-artifacts/$lang_path" ]; then
              echo "[]" > temp_versions.json
              
              local all_versions=($(find "./staged-artifacts/$lang_path" -maxdepth 1 -type d -exec basename {} \; | grep -v "^$(basename "./staged-artifacts/$lang_path")$"))
              
              # Separate main from version tags
              local main_version=""
              local tag_versions=()
              for v in "${all_versions[@]}"; do
                if [ "$v" = "main" ]; then
                  main_version="main"
                else
                  tag_versions+=("$v")
                fi
              done
              
              # Sort version tags by semver
              local sorted_tag_versions=()
              if [ ${#tag_versions[@]} -gt 0 ]; then
                IFS=$'\n' sorted_tag_versions=($(printf '%s\n' "${tag_versions[@]}" | sort -V -r))
              fi
              
              # Build final sorted list
              local final_versions=()
              if [ -n "$main_version" ]; then
                final_versions+=("$main_version")
              fi
              final_versions+=("${sorted_tag_versions[@]}")
              
              # Build JSON
              for version in "${final_versions[@]}"; do
                if [ -d "./staged-artifacts/$lang_path/$version" ]; then
                  if [ "$version" = "main" ]; then
                    versions_array=$(jq --argjson new '{
                      "name": "'$version'",
                      "url": "'$lang_path'/'$version'/", 
                      "isLatest": true
                    }' '. + [$new]' temp_versions.json)
                  else
                    versions_array=$(jq --argjson new '{
                      "name": "'$version'",
                      "url": "'$lang_path'/'$version'/",
                      "isLatest": false
                    }' '. + [$new]' temp_versions.json)
                  fi
                  echo "$versions_array" > temp_versions.json
                fi
              done
              
              versions_array=$(cat temp_versions.json)
              rm -f temp_versions.json
            fi
            
            echo "$versions_array"
          }
          
          # Generate JSON context for tera
          RUST_VERSIONS=$(fetch_rust_versions_json)
          PYTHON_VERSIONS=$(generate_bindings_versions_json 'python')
          C_VERSIONS=$(generate_bindings_versions_json 'c')
          CXX_VERSIONS=$(generate_bindings_versions_json 'cxx')
          
          jq -n \
            --arg title "iceoryx2 :: API Reference" \
            --arg description "Language bindings for the iceoryx2 zero-copy inter-process communication library" \
            --arg buildDate "$(date '+%Y-%m-%d %H:%M UTC')" \
            --argjson pythonVersions "$PYTHON_VERSIONS" \
            --argjson cVersions "$C_VERSIONS" \
            --argjson cxxVersions "$CXX_VERSIONS" \
            --argjson rustVersions "$RUST_VERSIONS" \
            '{
              title: $title,
              description: $description, 
              buildDate: $buildDate,
              languages: [
                {
                  name: "Rust",
                  path: "rust",
                  icon: "Rs",
                  className: "rust-icon", 
                  versions: $rustVersions
                },
                {
                  name: "Python",
                  path: "python",
                  icon: "Py",
                  className: "python-icon", 
                  versions: $pythonVersions
                },
                {
                  name: "C++", 
                  path: "cxx",
                  icon: "C++",
                  className: "cxx-icon",
                  versions: $cxxVersions
                },
                {
                  name: "C",
                  path: "c",
                  icon: "C",
                  className: "c-icon",
                  versions: $cVersions
                }
              ]
            }' > context.json
          
          # Generate landing page from tera template
          tera --file doc/api/templates/landing-page/index.html.tera --json context.json > ./staged-artifacts/index.html
          cp doc/api/templates/landing-page/styles.css ./staged-artifacts/

      - name: Upload artifact to GitHub Pages
        uses: actions/upload-pages-artifact@v3
        with:
          path: ./staged-artifacts
          retention-days: 90

      - name: Deploy GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
